<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>笔记-JavaScript判断数据类型的方法总结</title>
      <link href="/Blog/2020/03/12/%E7%AC%94%E8%AE%B0-JavaScript%E5%88%A4%E6%96%AD%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"/>
      <url>/Blog/2020/03/12/%E7%AC%94%E8%AE%B0-JavaScript%E5%88%A4%E6%96%AD%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="1-typeof"><a href="#1-typeof" class="headerlink" title="1: typeof"></a>1: typeof</h1><p><code>typeof</code> 操作符返回一个<code>字符串</code>，表示未经计算的操作数的类型。</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><blockquote><p>typeof operand<br>typeof(operand)</p></blockquote><p> <em>注: operand [ˈɑːpərænd] n. [计] 操作数</em></p> <a id="more"></a><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p><strong>operand</strong></p><p>一个表示对象或原始值的表达式，其类型将被返回</p><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><table><thead><tr><th>类型</th><th>结果</th></tr></thead><tbody><tr><td>Undefined</td><td>“undefined”</td></tr><tr><td>Null</td><td>“object”</td></tr><tr><td>Boolean</td><td>“boolean”</td></tr><tr><td>Number</td><td>“number”</td></tr><tr><td>BigInt <a href="https://zhuanlan.zhihu.com/p/36330307" target="_blank" rel="noopener">详细</a></td><td>“bigint”</td></tr><tr><td>String</td><td>“string”</td></tr><tr><td>Symbol(ES2015新增的数据类型)</td><td>“symbol”</td></tr><tr><td>Function对象</td><td>“function”</td></tr><tr><td>其他任何对象</td><td>“object”</td></tr><tr><td>___</td><td></td></tr><tr><td>## 注意！！！ null</td><td></td></tr></tbody></table><blockquote><p>typeof null === ‘object’;</p></blockquote><p>在 JavaScript 最初的实现中，JavaScript 中的值是由一个表示类型的标签和实际数据值表示的。对象的类型标签是 0。由于 null 代表的是空指针（大多数平台下值为 0x00），因此，null 的类型标签是 0，typeof null 也因此返回 “object”。</p><p>曾有一个 ECMAScript 的修复提案（通过选择性加入的方式），但被拒绝了。该提案会导致 typeof null === ‘null’。</p><h2 id="new"><a href="#new" class="headerlink" title="new"></a>new</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 除 Function 外的所有构造函数的类型都是 'object'</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'String'</span>);</span><br><span class="line"><span class="keyword">var</span> num = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> str; <span class="comment">// 返回 'object'</span></span><br><span class="line"><span class="keyword">typeof</span> num; <span class="comment">// 返回 'object'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> func = <span class="keyword">new</span> <span class="built_in">Function</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> func; <span class="comment">// 返回 'function'</span></span><br></pre></td></tr></table></figure><h1 id="2-toString"><a href="#2-toString" class="headerlink" title="2: toString"></a>2: toString</h1><p>toString 是 object 的原型方法，调用该方法，默认返回当前对象的 Class 。<br>对于 Object 对象，直接调用 toString()  就能返回 [object Object] 。而对于其他对象，则需要通过 call / apply 来调用才能返回正确的类型信息。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="string">''</span>) ;   <span class="comment">// [object String]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="number">1</span>) ;    <span class="comment">// [object Number]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">true</span>) ; <span class="comment">// [object Boolean]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">Symbol</span>()); <span class="comment">//[object Symbol]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">undefined</span>) ; <span class="comment">// [object Undefined]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">null</span>) ; <span class="comment">// [object Null]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="keyword">new</span> <span class="built_in">Function</span>()) ; <span class="comment">// [object Function]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="keyword">new</span> <span class="built_in">Date</span>()) ; <span class="comment">// [object Date]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call([]) ; <span class="comment">// [object Array]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="keyword">new</span> <span class="built_in">RegExp</span>()) ; <span class="comment">// [object RegExp]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="keyword">new</span> <span class="built_in">Error</span>()) ; <span class="comment">// [object Error]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">document</span>) ; <span class="comment">// [object HTMLDocument]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">window</span>) ; <span class="comment">//[object global] window 是全局对象 global 的引用</span></span><br></pre></td></tr></table></figure><h1 id="3-constructor"><a href="#3-constructor" class="headerlink" title="3: constructor"></a>3: constructor</h1><p>constructor 是原型 prototype 的一个属性，当函数被定义时候，js 引擎会为函数添加原型prototype，并且这个 prototype 中 constructor 属性指向函数引用， 因此重写 prototype 会丢失原来的constructor。</p><p><font color=red><strong>不过这种方法有问题：</strong></font></p><ol><li>null 和 undefined 无constructor，这种方法判断不了。</li><li>如果自定义对象，开发者重写prototype之后，原有的constructor会丢失，因此，为了规范开发，在重写对象原型时一般都需要重新给 constructor 赋值，以保证对象实例的类型不被篡改。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">''</span>.constructor === <span class="built_in">String</span> <span class="comment">//true</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">1</span>).constructor === <span class="built_in">Number</span> <span class="comment">//true</span></span><br><span class="line"><span class="literal">true</span>.constructor === <span class="built_in">Boolean</span> <span class="comment">//true</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Function</span>().constructor === <span class="built_in">Function</span> <span class="comment">//true</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>().constructor === <span class="built_in">Date</span> <span class="comment">//true</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Error</span>().constructor === <span class="built_in">Error</span> <span class="comment">//true</span></span><br><span class="line">[].constructor === <span class="built_in">Array</span> <span class="comment">//true</span></span><br><span class="line"><span class="built_in">document</span>.constructor === HTMLDocument <span class="comment">//true</span></span><br><span class="line"><span class="built_in">window</span>.constructor === Window <span class="comment">//true</span></span><br></pre></td></tr></table></figure><h1 id="4-instanceof"><a href="#4-instanceof" class="headerlink" title="4:instanceof"></a>4:instanceof</h1><p>字面翻译理解，<code>instance</code> 实例，即<br>instanceof 是用来判断 A 是否为 B 的实例，表达式为：A instanceof B，如果 A 是 B 的实例，则返回 true,否则返回 false。 在这里需要特别注意的是：instanceof 检测的是原型</p><p><img src="https://raw.githubusercontent.com/CoryLiu/Img-repo/master/img/%E6%8D%95%E8%8E%B7.JPG" alt=""></p><p>[]的原型指向 Array.prototype, 间接指向 Object.prototype</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[] <span class="keyword">instanceof</span> <span class="built_in">Array</span> === <span class="literal">true</span> <span class="comment">//true</span></span><br><span class="line">[] <span class="keyword">instanceof</span> <span class="built_in">Object</span> === <span class="literal">true</span> <span class="comment">//也是true</span></span><br></pre></td></tr></table></figure><p>所以 instanceof 只能用来判断两个对象是否属于实例关系， 而不能判断一个对象实例具体属于哪种类型。（JavaScript特殊的原型链机制）</p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>less,sass,scss笔记</title>
      <link href="/Blog/2020/03/08/less-sass-scss%E7%AC%94%E8%AE%B0/"/>
      <url>/Blog/2020/03/08/less-sass-scss%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="前言（css预处理器）"><a href="#前言（css预处理器）" class="headerlink" title="前言（css预处理器）"></a>前言（css预处理器）</h2><p>好多年前，从使用bootstrap开始，就接触过less<br>随着这些年前端技术的发展，现在越来越多的 <code>css预处理器</code> 被创造出来，web开发中，美工设计将不再是从前那种切图，然后生成冗长而又难以维护的css代码了<br>其实在我的理解看来，不论是less，sass，scss还是stylus，他们的诞生就是为了让css的编写更“程序化”，就像规定了一套约定和语法，然后可以通过解释与编译成css（最终生成的必定还是css，因为浏览器只认识css啊）<br>写下这篇笔记，梳理一下css预处理器的基础知识，方便之后自己查看</p><a id="more"></a><h2 id="sass"><a href="#sass" class="headerlink" title="sass"></a>sass</h2><p>按时间顺序来说，sass应该是最早出现的css预处理器   </p><blockquote><p>维基百科：Sass（英文全称：Syntactically Awesome Stylesheets）是一个最初由Hampton Catlin设计并由Natalie Weizenbaum开发的层叠样式表语言。在开发最初版本之后，Weizenbaum和Chris Eppstein继续通过SassScript来继续扩充Sass的功能。SassScript是一个在Sass文件中使用的小型脚本语言。</p></blockquote><p>在我的理解，sass和scss其实都属于sass。最初的sass是以换行和缩进来进行书写，看起来更接近于ruby，python的感觉，文件后缀 .sass 。而后又诞生了新的语法“scss”，文件后缀 .scss，相比sass，scss的语法更接近css，因为使用花括号作为分隔。而且scss完全兼容css，这就意味着，你可以直接复制从前的css到新的.scss文件中。</p><h2 id="less"><a href="#less" class="headerlink" title="less"></a>less</h2><p>2009年出现，受SASS的影响较大，但又使用CSS的语法，让大部分开发者和设计师更容易上手，在ruby社区之外支持者远超过SASS，其缺点是比起SASS来，可编程功能不够，不过优点是简单和兼容CSS，反过来也影响了SASS演变到了SCSS的时代，著名的Twitter Bootstrap就是采用LESS做底层语言的。</p><h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><blockquote><p><a href="http://lesscss.org/" target="_blank" rel="noopener">less官网</a></p></blockquote><blockquote><p><a href="https://www.sass.hk/" target="_blank" rel="noopener">sass中文网</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于前端工程化的理解</title>
      <link href="/Blog/2020/02/27/%E5%85%B3%E4%BA%8E%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E7%9A%84%E7%90%86%E8%A7%A3/"/>
      <url>/Blog/2020/02/27/%E5%85%B3%E4%BA%8E%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E7%9A%84%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>春节期间，太久没有动手写代码，不但生疏了基础知识，连理论概念都说不出来，今天静下心来，简单总结一下</p><h2 id="什么是前端工程化"><a href="#什么是前端工程化" class="headerlink" title="什么是前端工程化"></a>什么是前端工程化</h2><p>随着web业务日益复杂化和多元化，从前的前端，只是“做网页”“WebPage”而已，而如今，更像是在做一个“WebApp”。而且更多时候的需求也要求是单页面应用，这样对用户的体验会更佳，与传统的客户端程序或手机app一样。所以，前端开发，现在终于可以称得上是“软件开发”了。</p><a id="more"></a><p>既然是软件开发，那么就要有软件工程的概念：</p><ul><li>如何进行多人协作</li><li>如何保证项目的可维护性</li><li>如何让项目的开发流程可控</li><li>…</li></ul><p>总的来说，前端开发工程化就是使用软件工程技术和方法进行前端的开发流程，技术，工具，经验等规范化，标准化。<br>其实主要目的都是为了提高开发效率，降低维护成本，前端工程也可以是软件工程的一种。</p><ul><li>软件工程的定义是: “应用计算机科学理论和技术以及工程管理原则和方法，按预算和进度，实现满足用户要求的软件产品的定义、开发、和维护的工程或进行研究的学科”（GB/T11457-2006《信息技术 软件工程术语》）。</li></ul><h2 id="前端工程化具体是如何实现的"><a href="#前端工程化具体是如何实现的" class="headerlink" title="前端工程化具体是如何实现的"></a>前端工程化具体是如何实现的</h2><p>近些年，node.js的发展给前端工程化创造了条件，主要包含四个方面。“模块化”，“组件化”，“规范化”，“自动化”</p><h1 id="1：模块化"><a href="#1：模块化" class="headerlink" title="1：模块化"></a>1：模块化</h1><blockquote><p>简单来说，模块化就是把一个大文件按功能，按业务逻辑分成相互依赖的小文件，再统一拼装和加载</p></blockquote><h2 id="js的模块化"><a href="#js的模块化" class="headerlink" title="js的模块化"></a>js的模块化</h2><p>在ES6之前，JavaScript一直没有模块系统。因此大多使用CommonJS，AMD，CMD完成模块的拆分和加载</p><ol><li>用webpack+babel将所有模块打包成一个文件同步加载，也可以搭乘多个chunk异步加载；<blockquote><p>chunk表示一个文件，默认情况下webpack的输入是一个入口文件，输出也是一个文件，这个文件就是一个chunk，chunkId就是产出时给每个文件一个唯一标识id，chunkhash就是文件内容的md5值，name就是在entry中指定的key值。</p></blockquote></li><li>用++System+Babel++主要是分模块异步加载；</li><li>用浏览器的&lt;script type=”module”&gt;加载。</li></ol><h2 id="css的模块化"><a href="#css的模块化" class="headerlink" title="css的模块化"></a>css的模块化</h2><p>虽然SASS、LESS、Stylus等预处理器实现了CSS的文件拆分，但没有解决CSS模块化的一个重要问题：选择器的全局污染问题。</p><p>按道理，一个模块化的文件应该要隐藏内部作用域，只暴露少量接口给使用者。而按照目前预处理器的方式，导入一个CSS模块后，已存在的样式有被覆盖的风险。虽然重写样式是CSS的一个优势，但这并不利于多人协作。</p><p>为了避免全局选择器的冲突，需要制定CSS命名风格：</p><ul><li>BEM风格</li><li>Bootstrap风格</li><li>…<br>但是这毕竟是弱约束。所以很赞同一句话：</li></ul><blockquote><p>与其费尽心思地告诉别人要遵守某种规则，以规避某种痛苦，倒不如从工具层面就消灭这种痛苦。</p></blockquote><p>从工具层面，社区又创造出Shadow DOM、CSS in JS和CSS Modules三种解决方案。</p><ul><li>Shadow DOM是WebComponents的标准。它能解决全局污染问题，但目前很多浏览器不兼容，对我们来说还很久远；</li><li>CSS in JS是彻底抛弃CSS，使用JS或JSON来写样式。这种方法很激进，不能利用现有的CSS技术，而且处理伪类等问题比较困难；</li><li>CSS Modules仍然使用CSS，只是让JS来管理依赖。它能够最大化地结合CSS生态和JS模块化能力，目前来看是最好的解决方案。Vue的scoped style也算是一种。(vue的scope实现原理)</li></ul><h2 id="资源的模块化"><a href="#资源的模块化" class="headerlink" title="资源的模块化"></a>资源的模块化</h2><p>Webpack的强大之处不仅仅在于它统一了JS的各种模块系统，取代了Browserify、RequireJS、SeaJS的工作。更重要的是它的万能模块加载理念，即所有的资源都可以且也应该模块化。<br>资源模块化后，优点是：</p><ul><li>依赖关系单一化。所有CSS和图片等资源的依赖关系统一走JS路线，无需额外处理CSS预处理器的依赖关系，也不需处理代码迁移时的图片合并、字体图片等路径问题；</li><li>资源处理集成化。现在可以用loader对各种资源做各种事情，比如复杂的vue-loader等等；</li><li>项目结构清晰化。使用Webpack后，你的项目结构总可以表示成这样的函数： dest = webpack(src, config)。</li></ul><h1 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h1><p>从UI拆分下来的每个包含模板(HTML)+样式(CSS)+逻辑(JS)功能完备的结构单元，我们称之为组件。</p><blockquote><p>组件化≠模块化。模块化只是在文件层面上，对代码或资源的拆分；而组件化是在设计层面上，对UI（用户界面）的拆分。</p></blockquote><p>页面上所有的东西都是组件。页面是个大型组件，可以拆成若干个中型组件，然后中型组件还可以再拆，拆成若干个小型组件，小型组件也可以再拆，直到拆成DOM元素为止。DOM元素可以看成是浏览器自身的组件，作为组件的基本单元。</p><p>传统前端框架/类库的思想是先组织DOM，然后把某些可复用的逻辑封装成组件来操作DOM，是DOM优先；而组件化框架/类库的思想是先来构思组件，然后用DOM这种基本单元结合相应逻辑来实现组件，是组件优先。这是两者本质的区别。</p><p>其次，组件化实际上是一种按照模板(HTML)+样式(CSS)+逻辑(JS)三位一体的形式对面向对象的进一步抽象。</p><p>所以我们除了封装组件本身，还要合理处理组件之间的关系，比如 （逻辑）继承、（样式）扩展、（模板）嵌套和包含等，这些关系都可以归为依赖。</p><h1 id="规范化"><a href="#规范化" class="headerlink" title="规范化"></a>规范化</h1><p>规范化其实是工程化中很重要的一个部分，项目初期规范制定的好坏会直接影响到后期的开发质量。</p><p>比如：</p><ul><li><p>目录结构的制定</p><p>  目录结构的合理设定，能为项目带来很多优点：</p><ul><li>有助于提高项目的逻辑结构合理性；</li><li>对应扩展和合作；</li><li>方便资源的统一定位管理。</li></ul></li><li><p>规范编码</p><p>  制定一套良好的编码规范可以增强团队开发协作、提高代码质量。</p><p>  编码规范包括：</p><ul><li><p>HTML规范。</p><p>  基于 W3C、苹果开发者 等官方文档，并结合团队业务和开发过程中总结的规范约定，让页面HTML代码更具语义性。</p></li><li><p>CSS规范。</p><p>  统一规范团队 CSS 代码书写风格和使用 CSS 预编译语言语法风格，提供常用媒体查询语句和浏览器私有属性引用，并从业务层面统一规范常用模块的引用。</p></li><li><p>JS规范。</p><p>  统一规范团队 CSS 代码书写风格和使用 CSS 预编译语言语法风格，提供常用媒体查询语句和浏览器私有属性引用，并从业务层面统一规范常用模块的引用。</p></li><li><p>图片规范。</p><p>  了解各种图片格式特性，根据特性制定图片规范，包括但不限于图片的质量约定、图片引入方式、图片合并处理等，旨在从图片层面优化页面性能。</p></li><li><p>命名规范。</p><p>  从 目录、图片、HTML/CSS文件、ClassName 的命名等层面约定规范团队的命名习惯，增强团队代码的可读性。</p></li></ul></li><li><p>前后端接口规范</p><p>  “基于 Ajax 带来的 SPA 时代”，这种模式下，前后端的分工非常清晰，前后端的关键协作点是 Ajax 接口，引发一个重要问题：前后端的对接界面双方却关注甚少，没有任何接口约定规范情况下各自撸起袖子就是干，导致我们在产品项目开发过程中，前后端的接口联调对接工作量占比在30%-50%左右，甚至会更高。往往前后端接口联调对接及系统间的联调对接都是整个产品项目研发的软肋。</p><p>  接口规范主要初衷就是规范约定先行，尽量避免沟通联调产生的不必要的问题，让大家身心愉快地专注于各自擅长的领域。</p><p>  那么，对于这一SPA阶段，前后端分离有几个重要的关注挑战：</p><ul><li>职责分离</li></ul><ol><li><p>前后端仅仅通过异步接口(AJAX/JSONP)来编程；</p></li><li><p>前后端都各自有自己的开发流程，构建工具，测试集合；</p></li><li><p>关注点分离，前后端变得相对独立并松耦合。</p><table><thead><tr><th>后端</th><th>前端</th></tr></thead><tbody><tr><td>提供数据</td><td>接收数据，返回数据</td></tr><tr><td>处理业务逻辑</td><td>处理渲染逻辑</td></tr></tbody></table></li></ol><ul><li><p>规范原则</p><ol><li>接口返回数据即显示，前端仅做渲染逻辑处理；</li><li>渲染逻辑禁止跨多个接口调用；</li><li>前端关注交互、渲染逻辑，尽量避免业务逻辑处理的出现；</li><li>请求响应传输数据格式：JSON，JSON数据尽量简单轻量，避免多级JSON的出现；</li></ol></li><li><p>响应格式</p><ol><li>响应基本格式及处理状态值的规范。<ul><li>基本响应格式</li><li>列表响应格式</li></ul></li><li>特殊内容<ul><li>下拉框、复选框、单选框统一由后端逻辑判定选中返回给前端展示；</li><li>关于Boolean类型，JSON数据传输中一律使用1/0来标示，1为是/True，0为否/False</li><li>关于日期类型，JSON数据传输中一律使用字符串，具体日期格式因业务而定；</li></ul></li></ol></li><li><p>文档规范</p></li><li><p>组件管理</p></li><li><p>git分支管理</p></li><li><p>commit描述规范</p></li><li><p>视觉图标规范</p></li><li><p>…</p></li></ul></li></ul><h2 id="自动化"><a href="#自动化" class="headerlink" title="自动化"></a>自动化</h2><p>前端工程化的很多脏活累活都应该交给自动化工具来完成。需要秉持的一个理念是:</p><blockquote><p>任何简单机械的重复劳动都应该让机器去完成。</p></blockquote><ul><li>图标合并</li><li>持续继承</li><li>自动化构建</li><li>自动化部署</li><li>自动化测试</li></ul>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
          <category> Vue.js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记录下数组操作中的几个方法</title>
      <link href="/Blog/2020/02/11/%E8%AE%B0%E5%BD%95%E4%B8%8B%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C%E4%B8%AD%E7%9A%84%E5%87%A0%E4%B8%AA%E6%96%B9%E6%B3%95/"/>
      <url>/Blog/2020/02/11/%E8%AE%B0%E5%BD%95%E4%B8%8B%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C%E4%B8%AD%E7%9A%84%E5%87%A0%E4%B8%AA%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="关于数组"><a href="#关于数组" class="headerlink" title="关于数组"></a>关于数组</h2><p>避免使用new Array()</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> points = <span class="keyword">new</span> <span class="built_in">Array</span>();         <span class="comment">// 差</span></span><br><span class="line"><span class="keyword">var</span> points = [];                  <span class="comment">// 优</span></span><br></pre></td></tr></table></figure><p>原因：new 关键词只会使代码复杂化。它还会产生某些不可预期的结果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> points = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">40</span>, <span class="number">100</span>);  <span class="comment">// 创建包含两个元素的数组（40 和 100）</span></span><br></pre></td></tr></table></figure><p>加入只有一个元素</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> points = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">40</span>); <span class="comment">//创建了包含 40 个未定义元素的数组！！！</span></span><br></pre></td></tr></table></figure><hr><h2 id="数组操作常用方法"><a href="#数组操作常用方法" class="headerlink" title="数组操作常用方法"></a>数组操作常用方法</h2><h3 id="push"><a href="#push" class="headerlink" title="push()"></a>push()</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fruits = [<span class="string">"Banana"</span>, <span class="string">"Orange"</span>, <span class="string">"Apple"</span>, <span class="string">"Mango"</span>];</span><br><span class="line">fruits.push(<span class="string">"Kiwi"</span>);       <span class="comment">//  向 fruits 添加一个新元素</span></span><br></pre></td></tr></table></figure><h3 id="shift"><a href="#shift" class="headerlink" title="shift()"></a>shift()</h3><p>删除首个数组元素，并把所有其他元素“位移”到更低的索引。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fruits = [<span class="string">"Banana"</span>, <span class="string">"Orange"</span>, <span class="string">"Apple"</span>, <span class="string">"Mango"</span>];</span><br><span class="line">fruits.shift();            <span class="comment">// 从 fruits 删除第一个元素 "Banana"</span></span><br></pre></td></tr></table></figure><h3 id="unshift"><a href="#unshift" class="headerlink" title="unshift()"></a>unshift()</h3><p>unshift() 方法（在开头）向数组添加新元素：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fruits = [<span class="string">"Banana"</span>, <span class="string">"Orange"</span>, <span class="string">"Apple"</span>, <span class="string">"Mango"</span>];</span><br><span class="line">fruits.unshift(<span class="string">"Lemon"</span>);    <span class="comment">// 向 fruits 添加新元素 "Lemon"</span></span><br></pre></td></tr></table></figure><h3 id="splice"><a href="#splice" class="headerlink" title="splice()"></a>splice()</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fruits = [<span class="string">"Banana"</span>, <span class="string">"Orange"</span>, <span class="string">"Apple"</span>, <span class="string">"Mango"</span>];</span><br><span class="line">fruits.splice(<span class="number">2</span>, <span class="number">0</span>, <span class="string">"Lemon"</span>, <span class="string">"Kiwi"</span>);</span><br></pre></td></tr></table></figure><p>(2)表示位置<br>(0)表示从这个位置开始要删除的个数<br>其余表示要添加的元素</p><ul><li>使用splice()来删除元素<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fruits = [<span class="string">"Banana"</span>, <span class="string">"Orange"</span>, <span class="string">"Apple"</span>, <span class="string">"Mango"</span>];</span><br><span class="line">fruits.splice(<span class="number">0</span>, <span class="number">1</span>);        <span class="comment">// 删除 fruits 中的第一个元素</span></span><br></pre></td></tr></table></figure><h3 id="concat"><a href="#concat" class="headerlink" title="concat()"></a>concat()</h3>连接数组<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myGirls = [<span class="string">"Cecilie"</span>, <span class="string">"Lone"</span>];</span><br><span class="line"><span class="keyword">var</span> myBoys = [<span class="string">"Emil"</span>, <span class="string">"Tobias"</span>, <span class="string">"Linus"</span>];</span><br><span class="line"><span class="keyword">var</span> myChildren = myGirls.concat(myBoys);   <span class="comment">// 连接 myGirls 和 myBoys</span></span><br></pre></td></tr></table></figure><h3 id="slice"><a href="#slice" class="headerlink" title="slice()"></a>slice()</h3>截取数组<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fruits = [<span class="string">"Banana"</span>, <span class="string">"Orange"</span>, <span class="string">"Lemon"</span>, <span class="string">"Apple"</span>, <span class="string">"Mango"</span>];</span><br><span class="line"><span class="keyword">var</span> citrus = fruits.slice(<span class="number">1</span>); <span class="comment">// citrus:[ "Orange", "Lemon", "Apple", "Mango" ]</span></span><br></pre></td></tr></table></figure>slice() 可接受两个参数，比如 (1, 3)。<br>该方法会从开始参数选取元素，直到结束参数（不包括）为止。</li></ul><hr><h2 id="数据排序"><a href="#数据排序" class="headerlink" title="数据排序"></a>数据排序</h2><h3 id="sort-排序"><a href="#sort-排序" class="headerlink" title="sort() 排序"></a>sort() 排序</h3><p>sort() 方法以字母顺序对数组进行排序</p><h3 id="reverse-反转数组"><a href="#reverse-反转数组" class="headerlink" title="reverse() 反转数组"></a>reverse() 反转数组</h3><h3 id="sort-对数组数字进行排序"><a href="#sort-对数组数字进行排序" class="headerlink" title="sort()对数组数字进行排序"></a>sort()对数组数字进行排序</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> points = [<span class="number">40</span>, <span class="number">100</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">25</span>, <span class="number">10</span>];</span><br><span class="line">points.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>)</span>&#123;<span class="keyword">return</span> a - b&#125;);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> Array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Promise笔记</title>
      <link href="/Blog/2020/01/31/Promise%E7%AC%94%E8%AE%B0/"/>
      <url>/Blog/2020/01/31/Promise%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="使用Promise的目的"><a href="#使用Promise的目的" class="headerlink" title="使用Promise的目的"></a>使用Promise的目的</h2><p>Promise对延时和异步操作流进行控制</p><h2 id="Promise状态图"><a href="#Promise状态图" class="headerlink" title="Promise状态图"></a>Promise状态图</h2><p><img src="https://mdn.mozillademos.org/files/8633/promises.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Promise </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker常用命令</title>
      <link href="/Blog/2020/01/05/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/Blog/2020/01/05/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>简单记录一下初学的内容</p><a id="more"></a><h3 id="启动容器："><a href="#启动容器：" class="headerlink" title="启动容器："></a>启动容器：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run IMAGE [COMMAND] [ARG...]</span><br></pre></td></tr></table></figure><ul><li>docker run ubuntu echo ‘hello world’</li></ul><h3 id="启动交互式容器："><a href="#启动交互式容器：" class="headerlink" title="启动交互式容器："></a>启动交互式容器：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -i -t IMAGE /bin/bash</span><br></pre></td></tr></table></figure><ul><li>-i –interactive=true | false 默认 false</li><li>-t –tty=true | false 默认 false</li></ul><h3 id="查看容器："><a href="#查看容器：" class="headerlink" title="查看容器："></a>查看容器：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker ps [-a] [-l]</span><br><span class="line">$ docker inspect [容器名字，容器id]</span><br></pre></td></tr></table></figure><h3 id="重新启动停止的容器："><a href="#重新启动停止的容器：" class="headerlink" title="重新启动停止的容器："></a>重新启动停止的容器：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker start [-i] 容器名</span><br></pre></td></tr></table></figure><h3 id="进入容器【进入容器命令行】"><a href="#进入容器【进入容器命令行】" class="headerlink" title="进入容器【进入容器命令行】"></a>进入容器【进入容器命令行】</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker <span class="built_in">exec</span> -it [容器名，容器id] bash</span><br></pre></td></tr></table></figure><h3 id="删除停止的容器："><a href="#删除停止的容器：" class="headerlink" title="删除停止的容器："></a>删除停止的容器：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker rm 容器id</span><br></pre></td></tr></table></figure><h3 id="守护式容器"><a href="#守护式容器" class="headerlink" title="守护式容器"></a>守护式容器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d 镜像名 [COMMAND] [ARG...]</span><br></pre></td></tr></table></figure><hr><h3 id="运行docker"><a href="#运行docker" class="headerlink" title="运行docker"></a>运行docker</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -di --name=mynginx -p 8002:80 nginx</span><br></pre></td></tr></table></figure><ul><li>映射本地的8002端口</li></ul><h3 id="进入docker容器命令行"><a href="#进入docker容器命令行" class="headerlink" title="进入docker容器命令行"></a>进入docker容器命令行</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker <span class="built_in">exec</span> -it 镜像名 /bin/bash</span><br></pre></td></tr></table></figure><h3 id="部署静态页面到docker"><a href="#部署静态页面到docker" class="headerlink" title="部署静态页面到docker"></a>部署静态页面到docker</h3><ul><li>当前系统bash在vue项目的dist目录下</li><li>拷贝到名为mynginx的docker的默认html目录下<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker cp ./ mynginx:/usr/share/nginx/html</span><br></pre></td></tr></table></figure></li></ul><h2 id="迁移与备份"><a href="#迁移与备份" class="headerlink" title="迁移与备份"></a>迁移与备份</h2><ol><li>将容器保存为镜像 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker commit mynginx mynginx_i</span><br></pre></td></tr></table></figure></li><li>根据镜像生成运行新容器<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -id --name=mynginx2 -p 81:80 mynginx_i</span><br></pre></td></tr></table></figure></li><li>镜像导出为一个文件<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker save -o mynginx.tar mynginx_i</span><br></pre></td></tr></table></figure></li><li>文件恢复成镜像<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker load -i mynginx.tar</span><br></pre></td></tr></table></figure></li></ol><h3 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h3><p>需要先删除此镜像生成的容器</p><ol><li>停止容器</li><li>删除容器</li><li>删除镜像<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker stop 容器名</span><br><span class="line">$ docker rm 容器名</span><br><span class="line">$ docker rmi 镜像名</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker ps -a //查看所有容器</span><br><span class="line">$ docker images //查看所有镜像</span><br></pre></td></tr></table></figure></li></ol><hr><h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><p>相当于一个构建自定义镜像的脚本</p><blockquote><p><a href="https://docs.docker.com/engine/reference/builder/" target="_blank" rel="noopener">dockerfile官方文档说明 </a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>axios拦截器实现token认证</title>
      <link href="/Blog/2019/12/20/axios%E6%8B%A6%E6%88%AA%E5%99%A8%E5%AE%9E%E7%8E%B0token%E8%AE%A4%E8%AF%81/"/>
      <url>/Blog/2019/12/20/axios%E6%8B%A6%E6%88%AA%E5%99%A8%E5%AE%9E%E7%8E%B0token%E8%AE%A4%E8%AF%81/</url>
      
        <content type="html"><![CDATA[<blockquote><p>作者：mnn<br>链接：<a href="https://juejin.im/post/5bab739af265da0aa3593177" target="_blank" rel="noopener">https://juejin.im/post/5bab739af265da0aa3593177</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
          <category> Vue.js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> axios </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用http-server测试vue项目</title>
      <link href="/Blog/2019/12/19/%E4%BD%BF%E7%94%A8http-server%E6%B5%8B%E8%AF%95vue%E9%A1%B9%E7%9B%AE/"/>
      <url>/Blog/2019/12/19/%E4%BD%BF%E7%94%A8http-server%E6%B5%8B%E8%AF%95vue%E9%A1%B9%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="使用http-server测试vue打包的项目"><a href="#使用http-server测试vue打包的项目" class="headerlink" title="使用http-server测试vue打包的项目"></a>使用<code>http-server</code>测试vue打包的项目</h1><p>vue-cli build 打包后的项目，除了部署后预览外，也可以使用<code>http-server</code>快速预览。以下是详细说明：</p><a id="more"></a><blockquote><p><a href="https://github.com/http-party/http-server#readme" target="_blank" rel="noopener">项目 github 地址</a></p></blockquote><h1 id="http-server-a-command-line-http-server"><a href="#http-server-a-command-line-http-server" class="headerlink" title="http-server: a command-line http server"></a>http-server: a command-line http server</h1><p><code>http-server</code> is a simple, zero-configuration command-line http server.  It is powerful enough for production usage, but it’s simple and hackable enough to be used for testing, local development, and learning.</p><p><img src="https://github.com/nodeapps/http-server/raw/master/screenshots/public.png" alt=""></p><h1 id="Installing-globally"><a href="#Installing-globally" class="headerlink" title="Installing globally:"></a>Installing globally:</h1><p>Installation via <code>npm</code>:</p><pre><code>npm install http-server -g</code></pre><p>This will install <code>http-server</code> globally so that it may be run from the command line.</p><h2 id="Running-on-demand"><a href="#Running-on-demand" class="headerlink" title="Running on-demand:"></a>Running on-demand:</h2><p>Using <code>npx</code> you can run the script without installing it first:</p><pre><code>npx http-server [path] [options]</code></pre><h2 id="Usage"><a href="#Usage" class="headerlink" title="Usage:"></a>Usage:</h2><pre><code>http-server [path] [options]</code></pre><p><code>[path]</code> defaults to <code>./public</code> if the folder exists, and <code>./</code> otherwise.</p><p><em>Now you can visit <a href="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a> to view your server</em></p><p><strong>Note:</strong> Caching is on by default. Add <code>-c-1</code> as an option to disable caching.</p><h2 id="Available-Options"><a href="#Available-Options" class="headerlink" title="Available Options:"></a>Available Options:</h2><p><code>-p</code> or <code>--port</code> Port to use (defaults to 8080)</p><p><code>-a</code> Address to use (defaults to 0.0.0.0)</p><p><code>-d</code> Show directory listings (defaults to <code>true</code>)</p><p><code>-i</code> Display autoIndex (defaults to <code>true</code>)</p><p><code>-g</code> or <code>--gzip</code> When enabled (defaults to <code>false</code>) it will serve <code>./public/some-file.js.gz</code> in place of <code>./public/some-file.js</code> when a gzipped version of the file exists and the request accepts gzip encoding. If brotli is also enabled, it will try to serve brotli first.</p><p><code>-b</code> or <code>--brotli</code> When enabled (defaults to <code>false</code>) it will serve <code>./public/some-file.js.br</code> in place of <code>./public/some-file.js</code> when a brotli compressed version of the file exists and the request accepts <code>br</code> encoding. If gzip is also enabled, it will try to serve brotli first.</p><p><code>-e</code> or <code>--ext</code> Default file extension if none supplied (defaults to <code>html</code>)</p><p><code>-s</code> or <code>--silent</code> Suppress log messages from output</p><p><code>--cors</code> Enable CORS via the <code>Access-Control-Allow-Origin</code> header</p><p><code>-o [path]</code> Open browser window after starting the server. Optionally provide a URL path to open. e.g.: -o /other/dir/</p><p><code>-c</code> Set cache time (in seconds) for cache-control max-age header, e.g. <code>-c10</code> for 10 seconds (defaults to <code>3600</code>). To disable caching, use <code>-c-1</code>.</p><p><code>-U</code> or <code>--utc</code> Use UTC time format in log messages.</p><p><code>--log-ip</code> Enable logging of the client’s IP address (default: <code>false</code>).</p><p><code>-P</code> or <code>--proxy</code> Proxies all requests which can’t be resolved locally to the given url. e.g.: -P <a href="http://someurl.com" target="_blank" rel="noopener">http://someurl.com</a></p><p><code>--username</code> Username for basic authentication [none]</p><p><code>--password</code> Password for basic authentication [none]</p><p><code>-S</code> or <code>--ssl</code> Enable https.</p><p><code>-C</code> or <code>--cert</code> Path to ssl cert file (default: <code>cert.pem</code>).</p><p><code>-K</code> or <code>--key</code> Path to ssl key file (default: <code>key.pem</code>).</p><p><code>-r</code> or <code>--robots</code> Provide a /robots.txt (whose content defaults to <code>User-agent: *\nDisallow: /</code>)</p><p><code>--no-dotfiles</code> Do not show dotfiles</p><p><code>-h</code> or <code>--help</code> Print this list and exit.</p><p><code>-v</code> or <code>--version</code> Print the version and exit.</p><h2 id="Magic-Files"><a href="#Magic-Files" class="headerlink" title="Magic Files"></a>Magic Files</h2><ul><li><code>index.html</code> will be served as the default file to any directory requests.</li><li><code>404.html</code> will be served if a file is not found. This can be used for Single-Page App (SPA) hosting to serve the entry page.</li></ul><h2 id="Catch-all-redirect"><a href="#Catch-all-redirect" class="headerlink" title="Catch-all redirect"></a>Catch-all redirect</h2><p>To implement a catch-all redirect, use the index page itself as the proxy with:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http-server --proxy http://localhost:8080?</span><br></pre></td></tr></table></figure><p>Note the <code>?</code> at the end of the proxy URL. Thanks to <a href="https://github.com/houston3" target="_blank" rel="noopener">@houston3</a> for this clever hack!</p><h2 id="TLS-SSL"><a href="#TLS-SSL" class="headerlink" title="TLS/SSL"></a>TLS/SSL</h2><p>First, you need to make sure that <a href="https://github.com/openssl/openssl" target="_blank" rel="noopener">openssl</a> is installed correctly, and you have <code>key.pem</code> and <code>cert.pem</code> files. You can generate them using this command:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl req -newkey rsa:2048 -new -nodes -x509 -days 3650 -keyout key.pem -out cert.pem</span><br></pre></td></tr></table></figure><p>You will be prompted with a few questions after entering the command. Use <code>127.0.0.1</code> as value for <code>Common name</code> if you want to be able to install the certificate in your OS’s root certificate store or browser so that it is trusted.</p><p>This generates a cert-key pair and it will be valid for 3650 days (about 10 years).</p><p>Then you need to run the server with <code>-S</code> for enabling SSL and <code>-C</code> for your certificate file.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http-server -S -C cert.pem</span><br></pre></td></tr></table></figure><p>This is what should be output if successful:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Starting up http-server, serving ./ through https</span><br><span class="line">Available on:</span><br><span class="line">  https:127.0.0.1:8080</span><br><span class="line">  https:192.168.1.101:8080</span><br><span class="line">  https:192.168.1.104:8080</span><br><span class="line">Hit CTRL-C to stop the server</span><br></pre></td></tr></table></figure><h1 id="Development"><a href="#Development" class="headerlink" title="Development"></a>Development</h1><p>Checkout this repository locally, then:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm i</span><br><span class="line">$ node bin/http-server</span><br></pre></td></tr></table></figure><p><em>Now you can visit <a href="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a> to view your server</em></p><p>You should see the turtle image in the screenshot above hosted at that URL. See<br>the <code>./public</code> folder for demo content.</p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
          <category> Vue.js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Coding </tag>
            
            <tag> Vue.js </tag>
            
            <tag> Node.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript之call()与apply()</title>
      <link href="/Blog/2019/12/09/JavaScript%E4%B9%8Bcall/"/>
      <url>/Blog/2019/12/09/JavaScript%E4%B9%8Bcall/</url>
      
        <content type="html"><![CDATA[<h2 id="Function-prototype-call"><a href="#Function-prototype-call" class="headerlink" title="Function.prototype.call()"></a>Function.prototype.call()</h2><p><code>call</code>方法使用一个指定的<code>this</code>值和单独给出的一个或多个参数来调用一个函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Product</span>(<span class="params">name, price</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.price = price;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Food</span>(<span class="params">name, price</span>) </span>&#123;</span><br><span class="line">  Product.call(<span class="keyword">this</span>, name, price);</span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">        错误写法： Product(name,price) 相当于 Product.call(null,name,price)，</span></span><br><span class="line"><span class="comment">        非严格模式下，null或者undefined会自动替换为指向全局对象，如果在浏览器下则是</span></span><br><span class="line"><span class="comment">        window ，所以相当于Product.call(window,name,price)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="keyword">this</span>.category = <span class="string">'food'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> Food(<span class="string">'cheese'</span>, <span class="number">5</span>));</span><br><span class="line"><span class="comment">// 结果: Food &#123;name: "cheese", price: 5, category: "food"&#125;</span></span><br></pre></td></tr></table></figure><blockquote><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call" target="_blank" rel="noopener">MDN 文档 call</a></p></blockquote><h2 id="Function-prototype-apply"><a href="#Function-prototype-apply" class="headerlink" title="Function.prototype.apply()"></a>Function.prototype.apply()</h2><p><code>apply()</code> 方法调用一个具有给定<code>this</code>值的函数，以及作为一个数组（或类似数组对象）提供的参数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">5</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> max = <span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, numbers);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(max);</span><br><span class="line"><span class="comment">// expected output: 7</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> min = <span class="built_in">Math</span>.min.apply(<span class="literal">null</span>, numbers);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(min);</span><br><span class="line"><span class="comment">// expected output: 2</span></span><br></pre></td></tr></table></figure><h3 id="备注：Math-max"><a href="#备注：Math-max" class="headerlink" title="备注：Math.max"></a>备注：Math.max</h3><p><code>max</code> 是 <code>Math</code> 的静态方法，所以直接使用：<code>Math.max()</code>,而不是创建的<code>Math</code>实例的方法(<code>Math</code>不是构造函数，通过<code>typeof(Math)</code>可以看到，<code>Math</code>是一个<code>Object</code>,没有<code>prototype</code>)。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><blockquote><p><b style="font-size:1.4em">Math.max(value1[,value2,value3,…])</b></p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.max(numbers)</span><br><span class="line"><span class="comment">//运行结果 NaN</span></span><br></pre></td></tr></table></figure><p>若不使用<code>apply()</code>，运行结果为NaN，原因是相当于只提供了一个参数（numbers数组），<code>max</code>方法给定的参数无法被转换为数字，则会返回<code>NaN</code>。</p><blockquote><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/apply" target="_blank" rel="noopener">MDN 文档 apply</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Coding </tag>
            
            <tag> JavaScript </tag>
            
            <tag> call </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从npm迁移yarn</title>
      <link href="/Blog/2019/12/04/%E4%BB%8Enpm%E8%BF%81%E7%A7%BByarn/"/>
      <url>/Blog/2019/12/04/%E4%BB%8Enpm%E8%BF%81%E7%A7%BByarn/</url>
      
        <content type="html"><![CDATA[<p>Yarn和npm使用相同的 <code>package.json</code> 格式，而且从 npm 迁移 Yarn 可以从npm安装依赖包。</p><p>只需执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn</span><br></pre></td></tr></table></figure><p>Yarn 将通过自己的解析算法来重新组织 <code>node_modules</code> 目录，这个算法和<a href="https://nodejs.org/api/modules.html#modules_all_together" target="_blank" rel="noopener">node.js 模块解析算法</a>是兼容的。</p><a id="more"></a><h2 id="CLI命令比较"><a href="#CLI命令比较" class="headerlink" title="CLI命令比较"></a>CLI命令比较</h2><table><thead><tr><th>npm(v5)</th><th>Yarn</th></tr></thead><tbody><tr><td>npm install</td><td>yarn install</td></tr><tr><td>不适用</td><td>yarn install –flat</td></tr><tr><td>不适用</td><td>yarn install –har</td></tr><tr><td>npm install –no-package-lock</td><td>yarn install –no-lockfile</td></tr><tr><td>(不适用)</td><td>yarn install –pure-lockfile</td></tr><tr><td>npm install [package]</td><td>yarn add [package]</td></tr><tr><td>npm install [package] –save-dev</td><td>yarn add [package] –dev</td></tr><tr><td>(不适用)</td><td>yarn add [package] –peer</td></tr><tr><td>npm install [package] –save-optional</td><td>yarn add [package] –optional</td></tr><tr><td>npm install [package] –save-exact</td><td>yarn add [package] –exact</td></tr><tr><td>(不适用)</td><td>yarn add [package] –tilde</td></tr><tr><td>npm install [package] –global</td><td>yarn global add [package]</td></tr><tr><td>npm update –global</td><td>yarn global upgrade</td></tr><tr><td>npm rebuild</td><td>yarn install –force</td></tr><tr><td>npm uninstall [package]</td><td>yarn remove [package]</td></tr><tr><td>npm cache clean</td><td>yarn cache clean [package]</td></tr><tr><td>rm -rf node_modules &amp;&amp; npm install</td><td>yarn upgrade</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
          <category> Vue.js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> yarn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES6优化vue项目代码</title>
      <link href="/Blog/2019/12/02/ES6%E4%BC%98%E5%8C%96vue%E9%A1%B9%E7%9B%AE%E4%BB%A3%E7%A0%81/"/>
      <url>/Blog/2019/12/02/ES6%E4%BC%98%E5%8C%96vue%E9%A1%B9%E7%9B%AE%E4%BB%A3%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h2 id="ES6简写"><a href="#ES6简写" class="headerlink" title="ES6简写"></a>ES6简写</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//没有简写</span></span><br><span class="line">&#123;</span><br><span class="line">    method: &#123;</span><br><span class="line">        getValue: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    computed: &#123;</span><br><span class="line">        halfValue: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    created: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用ES6简写</span></span><br><span class="line">&#123;</span><br><span class="line">    method: &#123;</span><br><span class="line">        getValue() &#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    computed: &#123;</span><br><span class="line">        halfValue() &#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    created() &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解构"><a href="#解构" class="headerlink" title="解构"></a>解构</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">    name: <span class="string">'Jake'</span>,</span><br><span class="line">    email: <span class="string">'jake@example.com'</span>,</span><br><span class="line">    phone: <span class="string">'123-231-3123'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//没有解构</span></span><br><span class="line"><span class="keyword">const</span> name = person.name</span><br><span class="line"><span class="keyword">const</span> email = person.email</span><br><span class="line"><span class="keyword">const</span> phone = person.phone</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用解构</span></span><br><span class="line"><span class="keyword">const</span> &#123;</span><br><span class="line">    name,</span><br><span class="line">    email,</span><br><span class="line">    phone</span><br><span class="line">&#125; = person</span><br></pre></td></tr></table></figure><h3 id="Vue中主要两个领域适合做解构：-从-this-中解构属性；从作用域插槽接收-prop。"><a href="#Vue中主要两个领域适合做解构：-从-this-中解构属性；从作用域插槽接收-prop。" class="headerlink" title="Vue中主要两个领域适合做解构： 从 this 中解构属性；从作用域插槽接收 prop。"></a>Vue中主要两个领域适合做解构： 从 this 中解构属性；从作用域插槽接收 prop。</h3><h3 id="从this解构"><a href="#从this解构" class="headerlink" title="从this解构"></a>从this解构</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">data() &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            endpoint: <span class="string">'example.com/api'</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        postForm() &#123;</span><br><span class="line">            submitForm() &#123;</span><br><span class="line">                <span class="comment">//没有解构</span></span><br><span class="line">                <span class="keyword">const</span> endpoint = <span class="keyword">this</span>.endpoint</span><br><span class="line">                <span class="keyword">const</span> postForm = <span class="keyword">this</span>.postForm</span><br><span class="line"></span><br><span class="line">                <span class="comment">//使用解构</span></span><br><span class="line">                <span class="keyword">const</span> &#123;</span><br><span class="line">                    endpoint,</span><br><span class="line">                    postForm</span><br><span class="line">                &#125; = <span class="keyword">this</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>解构方式可以不用this前缀就使用这些变量，也可以清楚知道函数依赖于哪些数据和方法。</p><h3 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 不使用解构 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">User</span> <span class="attr">v-slot</span>=<span class="string">"slotProps"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>Name: &#123;&#123; slotProps.name &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>Email: &#123;&#123; slotProps.email &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">User</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 使用解构 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">User</span> <span class="attr">v-slot</span>=<span class="string">"&#123;name,email&#125;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>Name: &#123;&#123;name&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>Email: &#123;&#123;email&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">User</span>&gt;</span></span><br></pre></td></tr></table></figure><p>相比“从 this 解构”的模式，解构插槽 prop 不仅让我们可以不用 slotProps 前缀就访问变量，还向我们展示了通过插槽接收了哪些属性。</p><h2 id="新数组方法"><a href="#新数组方法" class="headerlink" title="新数组方法"></a>新数组方法</h2><p>map、排序数组、过滤数组<br>在Vue中常用的数组方法 filter、map、forEach、includes  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//filter示例</span></span><br><span class="line">computed: &#123;</span><br><span class="line">    <span class="comment">//不使用数组方法</span></span><br><span class="line">    oldFilteredItems() &#123;</span><br><span class="line">        <span class="keyword">const</span> filtered = []</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">in</span> <span class="keyword">this</span>.items) &#123;</span><br><span class="line">            <span class="keyword">if</span> (item.value &gt; <span class="number">10</span>) &#123;</span><br><span class="line">                filtered.push(item)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> filtered</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//使用数组方法</span></span><br><span class="line">    filteredItems() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.items.filter(<span class="function">(<span class="params">item</span>) =&gt;</span> item.value &gt; <span class="number">10</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">data() &#123;</span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">scrolled: <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">mounted() &#123;</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'scroll'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.scrolled = <span class="literal">true</span></span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码并不工作。创建新函数的时候，this 的值会重新绑定为等于函数实例，而不是Vue实例。<br>以下是解决方案：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mounted() &#123;</span><br><span class="line"><span class="keyword">var</span> self = <span class="keyword">this</span></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'scroll'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">self.scrolled = <span class="literal">true</span></span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然解决了问题，但是代码里<code>var self = this</code> 绝对难看，所以使用箭头函数解决此类问题   </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mounted() &#123;</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'scroll'</span>, () =&gt; &#123;</span><br><span class="line"><span class="keyword">this</span>.scrolled = <span class="literal">true</span></span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>箭头函数和this的关系，参照另一篇文章<a href="/2019/11/25/ES6箭头函数/">ES6箭头函数</a>，使用箭头函数替换标准函数，不会重新绑定this。</p></blockquote><p>编写Vue应用的时候，注意此规则：<code>在Vue组件中this应始终引用Vue实例。用好箭头函数的话这个目标很容易实现，这样你的代码就更容易理解了。</code></p><blockquote><p><a href="https://www.infoq.cn/article/mf_x3oizVrSruwpTevH5" target="_blank" rel="noopener">中文原文链接</a><br><a href="https://blog.logrocket.com/cleaning-up-your-vue-js-code-with-es6/" target="_blank" rel="noopener">英文原文链接</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
          <category> Vue.js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES6 </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES6箭头函数</title>
      <link href="/Blog/2019/11/25/ES6%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/"/>
      <url>/Blog/2019/11/25/ES6%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>ES6允许使用“箭头”（ <code>=&gt;</code> ）定义函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="params">v</span> =&gt;</span> v;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><a id="more"></a><p>如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数的部分。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="params">()</span> =&gt;</span> <span class="number">5</span>;</span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sum = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> num1 + num2;</span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用 <code>return</code> 语句返回。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>箭头函数可以与变量解构结合使用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> full = (&#123;</span><br><span class="line">    first,</span><br><span class="line">    last</span><br><span class="line">&#125;) =&gt; first + <span class="string">' '</span> + last;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">full</span>(<span class="params">person</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> person.first + <span class="string">' '</span> + person.last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>箭头函数使得表达更加简洁。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isEven = <span class="function"><span class="params">n</span> =&gt;</span> n % <span class="number">2</span> === <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> square = <span class="function"><span class="params">n</span> =&gt;</span> n * n;</span><br></pre></td></tr></table></figure><p>箭头函数的一个用处是简化回调函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正常函数写法</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].map(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭头函数写法</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].map(<span class="function"><span class="params">x</span> =&gt;</span> x * x);</span><br></pre></td></tr></table></figure><p>另一个例子是</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正常函数写法</span></span><br><span class="line"><span class="keyword">var</span> result = values.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭头函数写法</span></span><br><span class="line"><span class="keyword">var</span> result = values.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br></pre></td></tr></table></figure><p>下面是 rest 参数与箭头函数结合的例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = <span class="function">(<span class="params">...nums</span>) =&gt;</span> nums;</span><br><span class="line"></span><br><span class="line">numbers(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"><span class="comment">// [1,2,3,4,5]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> headAndTail = <span class="function">(<span class="params">head, ...tail</span>) =&gt;</span> [head, tail];</span><br><span class="line"></span><br><span class="line">headAndTail(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"><span class="comment">// [1,[2,3,4,5]]</span></span><br></pre></td></tr></table></figure><hr><h2 id="使用注意点"><a href="#使用注意点" class="headerlink" title="使用注意点"></a>使用注意点</h2><p>箭头函数的几个使用注意点：</p><ul><li>函数体内的 <code>this</code> 对象，就是定义时所在的对象，而不是使用时所在的对象。</li><li>不可以当作构造函数，也就是说，不可以使用 <code>new</code> 命令，否则会抛出一个错误。</li><li>不可以使用 <code>argument</code> 对象，该对象在函数体内不存在。如果要用，可以用rest参数代替。</li><li>不可以使用 <code>yield</code> 命令，因为箭头函数不能用作 Generator 函数。</li></ul><p><code>this</code> 对象的指向是可变的，但是在箭头函数中，它是固定的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'id'</span>, <span class="keyword">this</span>.id);</span><br><span class="line">    &#125;, <span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> id = <span class="number">23</span>;</span><br><span class="line"></span><br><span class="line">foo.call(&#123;</span><br><span class="line">    id: <span class="number">42</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中， <code>setTimeout</code> 的参数是一个箭头函数，这个箭头函数的定义生效是在 <code>foo</code> 函数生成时，而它的真正执行要等到100毫秒之后。如果是普通函数，执行时 <code>this</code> 应该指向全局对象 <code>window</code> ，这时应该输出 <code>21</code> 。但是，箭头函数导致 <code>this</code> 总是指向函数定义生效时所在的对象，所以输出的是 <code>42</code> 。</p><p>箭头函数可以让 <code>setTimeout</code> 里面的 <code>this</code> ，绑定定义时所在的作用域，而不是指向运行时所在的作用域。下面是另一个例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Timer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.s1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.s2 = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//箭头函数</span></span><br><span class="line">    setInterval(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">this</span>.s1++, <span class="number">1000</span>);</span><br><span class="line">    <span class="comment">//普通函数</span></span><br><span class="line">    setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.s2++;</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> timer = <span class="keyword">new</span> Timer()</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'s1: '</span>, timer.s1), <span class="number">3100</span>);</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'s2: '</span>, timer.s2), <span class="number">3100</span>);</span><br></pre></td></tr></table></figure><p>上面的代码中，<code>Timer</code>函数内部设置了两个定时器，分别使用了箭头函数和普通函数。<br>前者的<code>this</code>绑定定义时所在的作用域（即<code>Timer</code>函数），后者的<code>this</code>指向运行时所在的作用域（即全局对象）。所以，3100毫秒之后，<code>timer.s1</code>被更新了3次，而<code>timer.s2</code>一次也没有更新。</p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES6 </tag>
            
            <tag> 箭头函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue生命周期</title>
      <link href="/Blog/2019/11/21/vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
      <url>/Blog/2019/11/21/vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
          <category> Vue.js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>uni-app导航栏开发指南</title>
      <link href="/Blog/2019/11/20/uni-app%E5%AF%BC%E8%88%AA%E6%A0%8F%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/"/>
      <url>/Blog/2019/11/20/uni-app%E5%AF%BC%E8%88%AA%E6%A0%8F%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<blockquote><p>将官方社区的文章照搬过来，一方面正好在熟悉这块内容，另一方面熟练自己的md语法。<br>原文链接<a href="https://ask.dcloud.net.cn/article/34921" target="_blank" rel="noopener">https://ask.dcloud.net.cn/article/34921</a></p></blockquote><a id="more"></a><p>uni-app 自带原生导航栏，在pages.json里配置。<br>原生导航的体验更好，渲染新页面时，原生导航栏的渲染无需等待新页面dom加载，可以在新页面进入动画开始时就渲染。  </p><p>原生导航还可以避免滚动条通顶，并方便的控制原生下拉刷新。<br>通过pages.json的配置，可以简单的、跨端的、高性能的开发业务。  </p><p>但原生导航栏的扩展能力有限。尤其是微信下，没有提供太多导航栏的配置。<br>在App下，pages.json里每个页面的app-plus下可以设置titleNView等更多参数，可以得到比微信小程序更丰富的扩展性。<br>另外，开发者也可以在必要时取消原生导航栏，使用view自行绘制导航栏。</p><h2 id="原生导航栏的通用配置"><a href="#原生导航栏的通用配置" class="headerlink" title="原生导航栏的通用配置"></a><strong>原生导航栏的通用配置</strong></h2><p>原生导航栏的配置，均在pages.json里，每个page下面的style配置中的navigationBar各个参数配置，即为通用配置，小程序、app、h5均生效。参考<a href="https://uniapp.dcloud.io/collocation/pages?id=style" target="_blank" rel="noopener">https://uniapp.dcloud.io/collocation/pages?id=style</a></p><h2 id="全局取消原生导航栏"><a href="#全局取消原生导航栏" class="headerlink" title="全局取消原生导航栏"></a><strong>全局取消原生导航栏</strong></h2><p>在pages.json的globalStyle里，有个navigationStyle设置，默认是default，即带有原生导航栏。也可以设置为custom。<br>在设为custom后，所有页面都没有原生导航。<br>但在微信小程序里，右上角始终都有一个胶囊按钮。<br>很多微信小游戏界面也没原生导航栏，但有胶囊按钮。<br>一般App里不会使用这个参数配置。建议个别页面单独设置不使用原生导航，具体如下。</p><h2 id="单独去除原生导航栏"><a href="#单独去除原生导航栏" class="headerlink" title="单独去除原生导航栏"></a><strong>单独去除原生导航栏</strong></h2><p>自微信客户端7.0.0起，App端HBuilderX2.0.3起，支持通过如下方法取消单独一个页面的原生导航。但小程序右上角胶囊按钮仍然去不掉。页面配置 navigationStyle 为 custom:   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;path&quot; : &quot;pages/log.log&quot;,</span><br><span class="line">    &quot;style&quot; : &#123;</span><br><span class="line">        &quot;navigationStyle&quot;:&quot;custom&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
          <category> uni-app </category>
          
      </categories>
      
      
        <tags>
            
            <tag> uni-app </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo写作命令</title>
      <link href="/Blog/2019/11/20/hexo%E5%86%99%E4%BD%9C%E5%91%BD%E4%BB%A4/"/>
      <url>/Blog/2019/11/20/hexo%E5%86%99%E4%BD%9C%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="新建文章"><a href="#新建文章" class="headerlink" title="新建文章"></a><strong>新建文章</strong></h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure><p>layout : 默认为<code>post</code>，可以修改<code>_config.yml</code>中的<code>default_layout</code>参数来指定默认布局  </p><h1 id="布局（Layout）"><a href="#布局（Layout）" class="headerlink" title="布局（Layout）"></a><strong>布局（Layout）</strong></h1><p>Hexo 有三种默认布局：<code>post</code>、<code>page</code> 和 <code>draft</code>。在创建这三种不同类型的文件时，它们将会被保存到不同的路径；而您自定义的其他布局和 <code>post</code> 相同，都将存储到 <code>source/_posts</code> 文件夹中。  </p><table><thead><tr><th><strong>布局</strong></th><th><strong>路径</strong></th></tr></thead><tbody><tr><td><code>post</code></td><td><code>source/_posts</code></td></tr><tr><td><code>page</code></td><td><code>source</code></td></tr><tr><td><code>draft</code></td><td><code>source/_drafts</code></td></tr></tbody></table><blockquote><p>如果不希望文章被处理，可以将 Front-Matter 中的 <code>layout:</code> 设为 <code>false</code>。</p></blockquote><h1 id="预览"><a href="#预览" class="headerlink" title="预览"></a><strong>预览</strong></h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> 关于博客 </category>
          
          <category> hexo命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx+uwsgi+CentOS7部署Django</title>
      <link href="/Blog/2019/10/24/Nginx-uwsgi-CentOS7%E9%83%A8%E7%BD%B2Django/"/>
      <url>/Blog/2019/10/24/Nginx-uwsgi-CentOS7%E9%83%A8%E7%BD%B2Django/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
          <category> Django </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Django </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CAGED系统</title>
      <link href="/Blog/2019/10/24/CAGED%E7%B3%BB%E7%BB%9F/"/>
      <url>/Blog/2019/10/24/CAGED%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Guitar </category>
          
          <category> 乐理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 乐理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>七和弦</title>
      <link href="/Blog/2019/10/24/%E4%B8%83%E5%92%8C%E5%BC%A6/"/>
      <url>/Blog/2019/10/24/%E4%B8%83%E5%92%8C%E5%BC%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="七和弦的分类"><a href="#七和弦的分类" class="headerlink" title="七和弦的分类"></a>七和弦的分类</h1><h3 id="1-由4个音按照三度叠加构成，根音与最高音之间成七度音程"><a href="#1-由4个音按照三度叠加构成，根音与最高音之间成七度音程" class="headerlink" title="1. 由4个音按照三度叠加构成，根音与最高音之间成七度音程"></a>1. 由4个音按照三度叠加构成，根音与最高音之间成七度音程</h3><p><img src="https://cdn.jsdelivr.net/gh/CoryLiu/Img-repo@master/static_files/lyb/img/avatar20191025142352.png" alt=""></p><h3 id="2-七和弦的分类：在C大调顺阶和弦中，所有的三和弦都可以变化成七和弦"><a href="#2-七和弦的分类：在C大调顺阶和弦中，所有的三和弦都可以变化成七和弦" class="headerlink" title="2. 七和弦的分类：在C大调顺阶和弦中，所有的三和弦都可以变化成七和弦"></a>2. 七和弦的分类：在C大调顺阶和弦中，所有的三和弦都可以变化成七和弦</h3><p><img src="https://cdn.jsdelivr.net/gh/CoryLiu/Img-repo@master/static_files/lyb/img/avatar20191025142546.png" alt=""></p><ol start="3"><li>常用七和弦的组成音  <br>Maj7：1-3-5-7  (大七和弦)  Dom7：1-3-5-b7  (属七和弦)  min7：1-b3-5-b7  (小七和弦)</li></ol><a id="more"></a><hr><h1 id="几乎所有七和弦指法-不要背，需学会自己根据音程推导"><a href="#几乎所有七和弦指法-不要背，需学会自己根据音程推导" class="headerlink" title="几乎所有七和弦指法(不要背，需学会自己根据音程推导)"></a>几乎所有七和弦指法(不要背，需学会自己根据音程推导)</h1><h3 id="Seventh（属7）"><a href="#Seventh（属7）" class="headerlink" title="Seventh（属7）"></a>Seventh（属7）</h3><p><img src="https://cdn.jsdelivr.net/gh/CoryLiu/Img-repo@master/static_files/lyb/img/avatar20191025143705.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/CoryLiu/Img-repo@master/static_files/lyb/img/avatar20191025143854.png" alt=""></p><h3 id="Diminished-Seventh（减7）"><a href="#Diminished-Seventh（减7）" class="headerlink" title="Diminished Seventh（减7）"></a>Diminished Seventh（减7）</h3><p><img src="https://cdn.jsdelivr.net/gh/CoryLiu/Img-repo@master/static_files/lyb/img/avatar20191025144052.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/CoryLiu/Img-repo@master/static_files/lyb/img/avatar20191025144115.png" alt=""></p><h3 id="Seventh-Suspended-Fourth（7挂4）"><a href="#Seventh-Suspended-Fourth（7挂4）" class="headerlink" title="Seventh, Suspended Fourth（7挂4）"></a>Seventh, Suspended Fourth（7挂4）</h3><p><img src="https://cdn.jsdelivr.net/gh/CoryLiu/Img-repo@master/static_files/lyb/img/avatar20191025144203.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/CoryLiu/Img-repo@master/static_files/lyb/img/avatar20191025144215.png" alt=""></p><h3 id="Major-Seventh（大7）"><a href="#Major-Seventh（大7）" class="headerlink" title="Major Seventh（大7）"></a>Major Seventh（大7）</h3><p><img src="https://cdn.jsdelivr.net/gh/CoryLiu/Img-repo@master/static_files/lyb/img/avatar20191025144244.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/CoryLiu/Img-repo@master/static_files/lyb/img/avatar20191025144257.png" alt=""></p><h3 id="Minor-Seventh（小7）"><a href="#Minor-Seventh（小7）" class="headerlink" title="Minor Seventh（小7）"></a>Minor Seventh（小7）</h3><p><img src="https://cdn.jsdelivr.net/gh/CoryLiu/Img-repo@master/static_files/lyb/img/avatar20191025144331.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/CoryLiu/Img-repo@master/static_files/lyb/img/avatar20191025144342.png" alt=""></p><h3 id="Minor，Major-Seventh（小大7）"><a href="#Minor，Major-Seventh（小大7）" class="headerlink" title="Minor，Major Seventh（小大7）"></a>Minor，Major Seventh（小大7）</h3><p><img src="https://cdn.jsdelivr.net/gh/CoryLiu/Img-repo@master/static_files/lyb/img/avatar20191025144433.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/CoryLiu/Img-repo@master/static_files/lyb/img/avatar20191025144448.png" alt=""></p><h3 id="Major-Seventh，Flat-Fifth（大7降5）"><a href="#Major-Seventh，Flat-Fifth（大7降5）" class="headerlink" title="Major Seventh，Flat Fifth（大7降5）"></a>Major Seventh，Flat Fifth（大7降5）</h3><p><img src="https://cdn.jsdelivr.net/gh/CoryLiu/Img-repo@master/static_files/lyb/img/avatar20191025144638.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/CoryLiu/Img-repo@master/static_files/lyb/img/avatar20191025144652.png" alt=""></p><h3 id="Minor-Seeventh，Flat-Fifth（小7降5）"><a href="#Minor-Seeventh，Flat-Fifth（小7降5）" class="headerlink" title="Minor Seeventh，Flat Fifth（小7降5）"></a>Minor Seeventh，Flat Fifth（小7降5）</h3><p><img src="https://cdn.jsdelivr.net/gh/CoryLiu/Img-repo@master/static_files/lyb/img/avatar20191025144740.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/CoryLiu/Img-repo@master/static_files/lyb/img/avatar20191025144752.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Guitar </category>
          
          <category> 乐理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 乐理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/Blog/2019/10/20/hello-world/"/>
      <url>/Blog/2019/10/20/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
