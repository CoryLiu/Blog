<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>H5唤起APP的方式</title>
      <link href="/Blog/2020/06/18/H5%E5%94%A4%E8%B5%B7APP%E7%9A%84%E6%96%B9%E5%BC%8F/"/>
      <url>/Blog/2020/06/18/H5%E5%94%A4%E8%B5%B7APP%E7%9A%84%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h1><p>H5首页作为落地页，落地页承担的职责就是引流。引流有两种形式，同时也是我们对唤端的定义：引导已下载用户打开APP，引导未下载用户下载APP。</p><a id="more"></a><h1 id="唤端媒介"><a href="#唤端媒介" class="headerlink" title="唤端媒介"></a>唤端媒介</h1><h2 id="URL-Scheme"><a href="#URL-Scheme" class="headerlink" title="URL Scheme"></a>URL Scheme</h2><h3 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h3><p>URL Scheme</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[schema:][&#x2F;&#x2F;authority][path][?query][#fragment]</span><br></pre></td></tr></table></figure><h3 id="常用APP的-URL-Scheme"><a href="#常用APP的-URL-Scheme" class="headerlink" title="常用APP的 URL Scheme"></a>常用APP的 URL Scheme</h3><table><thead><tr><th>APP</th><th>微信</th><th>支付宝</th><th>淘宝</th><th>微博</th><th>QQ</th><th>知乎</th><th>短信</th></tr></thead><tbody><tr><td>URL Schema</td><td>weixin://</td><td>alipay://</td><td>taobao://</td><td>sinaweibo://</td><td>mqq://</td><td>zhihu://</td><td>sms://</td></tr></tbody></table><h3 id="URL-Scheme-语法"><a href="#URL-Scheme-语法" class="headerlink" title="URL Scheme 语法"></a>URL Scheme 语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     行为(应用的某个功能)    </span><br><span class="line">            |</span><br><span class="line">scheme:&#x2F;&#x2F;[path][?query]</span><br><span class="line">   |               |</span><br><span class="line">应用标识       功能需要的参数</span><br></pre></td></tr></table></figure><h2 id="判断唤端是否成功"><a href="#判断唤端是否成功" class="headerlink" title="判断唤端是否成功"></a>判断唤端是否成功</h2><p>如果唤端失败（APP 未安装），我们总是要做一些处理的，可以是跳转下载页，可以是 ios 下跳转 App Store… 但是Js 并不能提供给我们获取 APP 唤起状态的能力，Android Intent 以及 Universal Link 倒是不用担心，它们俩的自身机制允许它们唤端失败后直接导航至相应的页面，但是 URL Scheme 并不具备这样的能力，所以我们只能通过一些很 hack 的方式来实现 APP 唤起检测功能。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一般情况下是 visibilitychange </span></span><br><span class="line"><span class="keyword">const</span> visibilityChangeProperty = getVisibilityChangeProperty();</span><br><span class="line"><span class="keyword">const</span> timer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> hidden = isPageHidden();</span><br><span class="line">  <span class="keyword">if</span> (!hidden) &#123;</span><br><span class="line">    cb();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, timeout);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (visibilityChangeProperty) &#123;</span><br><span class="line">  <span class="built_in">document</span>.addEventListener(visibilityChangeProperty, () =&gt; &#123;</span><br><span class="line">    clearTimeout(timer);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'pagehide'</span>, () =&gt; &#123;</span><br><span class="line">  clearTimeout(timer);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>APP 如果被唤起的话，页面就会进入后台运行，会触发页面的 visibilitychange 事件。如果触发了，则表明页面被成功唤起，及时调用 clearTimeout ，清除页面未隐藏时的失败函数（callback）回调。<br>当然这个事件是有兼容性的，具体的代码实现时做了事件是否需要添加前缀（比如 -webkit- ）的校验。如果都不兼容，我们将使用 pagehide 事件来做兜底处理。</p><h2 id="开箱即用的callapp-lib"><a href="#开箱即用的callapp-lib" class="headerlink" title="开箱即用的callapp-lib"></a>开箱即用的callapp-lib</h2><p> npm 包 <a href="https://www.npmjs.com/package/callapp-lib" target="_blank" rel="noopener">callapp-lib</a></p><p> calapp-lib <a href="https://github.com/suanmei/callapp-lib" target="_blank" rel="noopener">文档</a></p><blockquote><p>作者：_拾邑<br>链接：<a href="https://juejin.im/post/5b7efb2ee51d45388b6af96c" target="_blank" rel="noopener">https://juejin.im/post/5b7efb2ee51d45388b6af96c</a><br>来源：掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Codding </category>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Html5 </tag>
            
            <tag> Scheme </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx配置笔记</title>
      <link href="/Blog/2020/05/18/nginx%E9%85%8D%E7%BD%AE%E7%AC%94%E8%AE%B0/"/>
      <url>/Blog/2020/05/18/nginx%E9%85%8D%E7%BD%AE%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="1-location"><a href="#1-location" class="headerlink" title="1 location"></a>1 location</h1><table><thead><tr><th>符号</th><th>含义</th></tr></thead><tbody><tr><td>location = /url</td><td><code>=</code> 精确匹配，uri必须完全一致才能匹配成功</td></tr><tr><td>location ^~ /Purl</td><td><code>^~</code> Puri和请求url的开头相同就匹配成功，且不再去匹配正则，也属于普通匹配</td></tr><tr><td>location /Purl</td><td><code>普通匹配</code>，Purl和用户请求url的开头相同就匹配成功，如果有多个普通匹配就匹配成功则按最长的。</td></tr><tr><td>location ~ reg</td><td><code>~</code> 区分大小写的正则匹配</td></tr><tr><td>location ~* reg</td><td><code>~*</code> 不区分大小写的正则匹配</td></tr></tbody></table><p>location的匹配顺序是： <code>= /url</code> &gt; <code>^~ /Purl</code> &gt; <code>/Purl</code> &gt; <code>~ 和 ~*</code></p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">实际使用中，个人觉得每个虚拟主机下（server节点下）至少有三个匹配规则定义，如下：</span><br><span class="line">#直接匹配网站根，通过域名访问网站首页比较频繁，使用这个会加速处理，官网如是说。</span><br><span class="line">#这里是直接转发给后端应用服务器了，也可以是一个静态首页</span><br><span class="line"># 第一个必选规则</span><br><span class="line">location &#x3D; &#x2F; &#123;</span><br><span class="line">    proxy_pass http:&#x2F;&#x2F;tomcat:8080&#x2F;index</span><br><span class="line">&#125;</span><br><span class="line"># 第二个必选规则是处理静态文件请求，这是nginx作为http服务器的强项</span><br><span class="line"># 有两种配置模式，目录匹配或后缀匹配,任选其一或搭配使用</span><br><span class="line">location ^~ &#x2F;static&#x2F; &#123;</span><br><span class="line">    root &#x2F;webroot&#x2F;static&#x2F;;</span><br><span class="line">&#125;</span><br><span class="line">location ~* \.(gif|jpg|jpeg|png|css|js|ico)$ &#123;</span><br><span class="line">    root &#x2F;webroot&#x2F;res&#x2F;;</span><br><span class="line">&#125;</span><br><span class="line">#第三个规则就是通用规则，用来转发动态请求到后端应用服务器</span><br><span class="line">#非静态文件请求就默认是动态请求，自己根据实际把握</span><br><span class="line">#毕竟目前的一些框架的流行，带.php,.jsp后缀的情况很少了</span><br><span class="line">location &#x2F; &#123;</span><br><span class="line">    proxy_pass http:&#x2F;&#x2F;tomcat:8080&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
          <category> 部署相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>django-admin美化插件simpleui</title>
      <link href="/Blog/2020/05/12/django-admin%E7%BE%8E%E5%8C%96%E6%8F%92%E4%BB%B6simpleui/"/>
      <url>/Blog/2020/05/12/django-admin%E7%BE%8E%E5%8C%96%E6%8F%92%E4%BB%B6simpleui/</url>
      
        <content type="html"><![CDATA[<blockquote><p>GitHub主页 <a href="https://github.com/newpanjing/simpleui" target="_blank" rel="noopener">https://github.com/newpanjing/simpleui</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
          <category> Django </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Django </tag>
            
            <tag> simpleui </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用git rebase合并</title>
      <link href="/Blog/2020/04/28/%E4%BD%BF%E7%94%A8git-rebase%E5%90%88%E5%B9%B6/"/>
      <url>/Blog/2020/04/28/%E4%BD%BF%E7%94%A8git-rebase%E5%90%88%E5%B9%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="使用git-rebase合并分支，可以使提交的log更加简洁"><a href="#使用git-rebase合并分支，可以使提交的log更加简洁" class="headerlink" title="使用git rebase合并分支，可以使提交的log更加简洁"></a>使用git rebase合并分支，可以使提交的log更加简洁</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout b1</span><br><span class="line">$ git rebase master</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Coding </tag>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Promise应用场景</title>
      <link href="/Blog/2020/04/21/Promise%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
      <url>/Blog/2020/04/21/Promise%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a>Promise.all</h1><p><strong>语法：Promise.all(iterable)</strong><br><strong>参数：一个可迭代对象，如Array</strong><br><strong>返回值</strong>   </p><ul><li>如果传递的iterable为空，则是已解决的Promise。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.all([]).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li>异步解析的Promise（如果传递的Iterable不包含Promise）。 请注意，在这种情况下，Google Chrome 58返回已解决的承诺。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.all([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)<span class="comment">//[1,2,3]</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><a id="more"></a></li><li>当给定可迭代对象中的所有promise已解决，或者任何promise均被拒绝时，此返回的promise将被异步解析/拒绝（堆栈为空时）<ul><li>当给定可迭代对象中的所有promise 已解决<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    resolve(<span class="number">1</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    resolve(<span class="number">2</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all([promise1,promise2,<span class="number">3</span>]).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)<span class="comment">//[1,2,3]</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES6 </tag>
            
            <tag> JavaScript </tag>
            
            <tag> Promise </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器兼容性配置</title>
      <link href="/Blog/2020/04/07/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%E6%80%A7%E9%85%8D%E7%BD%AE/"/>
      <url>/Blog/2020/04/07/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%E6%80%A7%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="开发代码兼容"><a href="#开发代码兼容" class="headerlink" title="开发代码兼容"></a>开发代码兼容</h1><p>Vue CLI 3初始化的项目，构建时会根据<code>package.json</code>中的<code>browserslist</code>配置自动检测需要转译的语言特性，为构建代码转译JavaScript 并为 CSS 添加浏览器前缀，通常只需要修改<code>browserslist</code>即可兼容目标浏览器，例如兼容IE10可以做如下配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"browserslist"</span>: [</span><br><span class="line">    <span class="string">"ie 10"</span></span><br><span class="line">  ]</span><br></pre></td></tr></table></figure><h1 id="依赖包兼容"><a href="#依赖包兼容" class="headerlink" title="依赖包兼容"></a>依赖包兼容</h1><p>但该特性仅对源码(src/)有效，对依赖包无效，当依赖包需要做兼容性转译时，有三种选择：   </p><ol><li>如果确切知道有兼容性问题的依赖包名，可以配置项目根目录下的<code>vue.config.js</code>（默认不存在），将依赖包名添加到<code>transpileDependencies</code>键中，这会为该依赖同时开启语法语法转换和根据使用情况检测 polyfill。例如：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    transpileDependencies: [<span class="string">"vue-plugin-load-script"</span>]       <span class="comment">// 需要编译的依赖包名</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>如果确切的知道需要转译的语言特性，可以配置根目录下的babel.config.js，为presets的值添加所需要的 polyfill，例如：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  presets: [</span><br><span class="line">    [<span class="string">'@vue/app'</span>, &#123;</span><br><span class="line">      polyfills: [</span><br><span class="line">        <span class="string">'es6.symbol'</span></span><br><span class="line">      ]</span><br><span class="line">    &#125;]</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>然而更多的情况是，我们并不确切的知道项目中引发兼容问题的具体原因，这时还可以配置为根据兼容目标导入所有 polyfill，需要设置babel.config.js为：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  presets: [</span><br><span class="line">    [<span class="string">'@vue/app'</span>, &#123;</span><br><span class="line">        useBuiltIns: <span class="string">'entry'</span></span><br><span class="line">    &#125;]</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>同时在入口文件（main.js）第一行添加<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'@babel/polyfill'</span></span><br></pre></td></tr></table></figure>这种方式可能导入代码中不需要的polyfill，从而使打包体积更大。</li></ol><h1 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h1><ul><li>IE10中的node节点列表不支持<code>forEach</code>方法</li><li>IE10中background的参数中如果包括background-size参数，则background-size必须跟在background-position后面，且加上/前缀，例如：<code>background:url(./img/b.jpg) center /cover no-repeat</code>;</li></ul><blockquote><p>转自 <a href="https://refined-x.com/2018/12/04/VueCLI3%20%E5%85%BC%E5%AE%B9%E6%80%A7%E9%85%8D%E7%BD%AE/" target="_blank" rel="noopener">前端路上原创技术文章</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
          <category> Vue.js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue.js </tag>
            
            <tag> IE兼容 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue axios nginx node expresss跨域</title>
      <link href="/Blog/2020/04/02/vue-axios-nginx-node-expresss%E8%B7%A8%E5%9F%9F/"/>
      <url>/Blog/2020/04/02/vue-axios-nginx-node-expresss%E8%B7%A8%E5%9F%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><ol><li>vue-cli4</li><li>axios</li><li>部署nginx</li><li>后端express 跨域</li></ol><a id="more"></a><h1 id="express-跨域设置"><a href="#express-跨域设置" class="headerlink" title="express 跨域设置"></a>express 跨域设置</h1><ol><li><p>手动：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置跨域访问</span></span><br><span class="line">app.use(<span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">  res.header(<span class="string">'Access-Control-Allow-Origin'</span>, <span class="string">'*'</span>)</span><br><span class="line">  res.header(<span class="string">'Access-Control-Allow-Headers'</span>, <span class="string">'Authorization,X-API-KEY, Origin, X-Requested-With, Content-Type, Accept, Access-Control-Request-Method'</span> )</span><br><span class="line">  res.header(<span class="string">'Access-Control-Allow-Methods'</span>, <span class="string">'GET, POST, OPTIONS, PATCH, PUT, DELETE'</span>)</span><br><span class="line">  res.header(<span class="string">'Allow'</span>, <span class="string">'GET, POST, PATCH, OPTIONS, PUT, DELETE'</span>)</span><br><span class="line">  next();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>安装<code>cors</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm install cors --save-dev</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cors = <span class="built_in">require</span>(<span class="string">'cors'</span>);</span><br><span class="line">app.use(cors());</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
          <category> express </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> cors </tag>
            
            <tag> node </tag>
            
            <tag> express </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue动态加载的侧边栏，刷新页面出现错误解决方式</title>
      <link href="/Blog/2020/03/31/Vue%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E7%9A%84%E4%BE%A7%E8%BE%B9%E6%A0%8F%EF%BC%8C%E5%88%B7%E6%96%B0%E9%A1%B5%E9%9D%A2%E5%87%BA%E7%8E%B0%E9%94%99%E8%AF%AF%E8%A7%A3%E5%86%B3%E6%96%B9%E5%BC%8F/"/>
      <url>/Blog/2020/03/31/Vue%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E7%9A%84%E4%BE%A7%E8%BE%B9%E6%A0%8F%EF%BC%8C%E5%88%B7%E6%96%B0%E9%A1%B5%E9%9D%A2%E5%87%BA%E7%8E%B0%E9%94%99%E8%AF%AF%E8%A7%A3%E5%86%B3%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h1><p>开发使用 <a href="https://github.com/PanJiaChen/vue-admin-template" target="_blank" rel="noopener">vue-admin-template</a>二次开发。<br>使用从后端获取路由数据，然后前端渲染的动态加载方式。<br>刷新动态加载进来的路由页面，会直接跳转到404页面（前提：路由里有配置404页面，否则是一片空白）</p><p>解决方式：在vue-router的<code>全局前置守卫</code>router.beforeEach里<code>next()</code>改为<code>next({...to,replace:true})</code></p><a id="more"></a><p>详细代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">router.beforeEach(<span class="keyword">async</span>(to, <span class="keyword">from</span>, next) =&gt; &#123;</span><br><span class="line">    <span class="comment">// start progress bar</span></span><br><span class="line">  NProgress.start()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// set page title</span></span><br><span class="line">  <span class="built_in">document</span>.title = getPageTitle(to.meta.title)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// determine whether the user has logged in</span></span><br><span class="line">  <span class="keyword">const</span> hasToken = getToken()</span><br><span class="line">  <span class="keyword">if</span> (hasToken) &#123;</span><br><span class="line">    <span class="keyword">if</span> (to.path === <span class="string">'/login'</span>) &#123;</span><br><span class="line">      <span class="comment">// if is logged in, redirect to the home page</span></span><br><span class="line">      next(&#123; <span class="attr">path</span>: <span class="string">'/'</span> &#125;)</span><br><span class="line">      NProgress.done()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> hasGetUserInfo = store.getters.phone</span><br><span class="line">      <span class="keyword">if</span> (hasGetUserInfo) &#123;</span><br><span class="line">        next()</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// get user info</span></span><br><span class="line">          <span class="keyword">await</span> store.dispatch(<span class="string">'user/getInfo'</span>)</span><br><span class="line">          <span class="keyword">let</span> routes=<span class="keyword">await</span> getAsyncRoutes()</span><br><span class="line">          <span class="comment">// 获取动态路由</span></span><br><span class="line">          <span class="keyword">await</span> store.dispatch(<span class="string">'permission/generateRoutes'</span>, routes)</span><br><span class="line">          router.addRoutes([&#123; <span class="attr">path</span>: <span class="string">'*'</span>, <span class="attr">redirect</span>: <span class="string">'/404'</span>, <span class="attr">hidden</span>: <span class="literal">true</span> &#125;])</span><br><span class="line">          next(&#123; ...to, <span class="attr">replace</span>: <span class="literal">true</span> &#125;)</span><br><span class="line">          <span class="comment">// next()</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">          <span class="comment">// remove token and go to login page to re-login</span></span><br><span class="line">          <span class="keyword">await</span> store.dispatch(<span class="string">'user/resetToken'</span>)</span><br><span class="line">          Message.error(error || <span class="string">'Has Error'</span>)</span><br><span class="line">          next(<span class="string">`/login?redirect=<span class="subst">$&#123;to.path&#125;</span>`</span>)</span><br><span class="line">          NProgress.done()</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/* has no token*/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (whiteList.indexOf(to.path) !== <span class="number">-1</span>) &#123;</span><br><span class="line">      <span class="comment">// in the free login whitelist, go directly</span></span><br><span class="line">      next()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// other pages that do not have permission to access are redirected to the login page.</span></span><br><span class="line">      next(<span class="string">`/login?redirect=<span class="subst">$&#123;to.path&#125;</span>`</span>)</span><br><span class="line">      NProgress.done()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
          <category> Vue.js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>express笔记</title>
      <link href="/Blog/2020/03/31/express%E7%AC%94%E8%AE%B0/"/>
      <url>/Blog/2020/03/31/express%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install express --save</span><br></pre></td></tr></table></figure><h1 id="Express应用程序生成器"><a href="#Express应用程序生成器" class="headerlink" title="Express应用程序生成器"></a>Express应用程序生成器</h1><p>express-generator 快速创建一个应用的骨架   </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g express-generator</span><br></pre></td></tr></table></figure><h2 id="express命令行参数"><a href="#express命令行参数" class="headerlink" title="express命令行参数"></a>express命令行参数</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">express -h</span><br><span class="line"></span><br><span class="line">  Usage: express [options] [dir]</span><br><span class="line"></span><br><span class="line">  Options:</span><br><span class="line"></span><br><span class="line">    -h, --<span class="built_in">help</span>          输出使用方法</span><br><span class="line">        --version       输出版本号</span><br><span class="line">    -e, --ejs           添加对 ejs 模板引擎的支持</span><br><span class="line">        --hbs           添加对 handlebars 模板引擎的支持</span><br><span class="line">        --pug           添加对 pug 模板引擎的支持</span><br><span class="line">    -H, --hogan         添加对 hogan.js 模板引擎的支持</span><br><span class="line">        --no-view       创建不带视图引擎的项目</span><br><span class="line">    -v, --view &lt;engine&gt; 添加对视图引擎（view） &lt;engine&gt; 的支持 (ejs|hbs|hjs|jade|pug|twig|vash) （默认是 jade 模板引擎）</span><br><span class="line">    -c, --css &lt;engine&gt;  添加样式表引擎 &lt;engine&gt; 的支持 (less|stylus|compass|sass) （默认是普通的 css 文件）</span><br><span class="line">        --git           添加 .gitignore</span><br><span class="line">    -f, --force         强制在非空目录下创建</span><br></pre></td></tr></table></figure><p>例：创建了一个名称为 myapp 的 Express 应用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">express --view=pug myapp</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> myapp</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure><h2 id="启动app"><a href="#启动app" class="headerlink" title="启动app"></a>启动app</h2><p>MacOS or Linux：   </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DEBUG=myapp:* npm start</span><br></pre></td></tr></table></figure><p>Windows</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> DEBUG=myapp:*</span><br><span class="line">npm start</span><br></pre></td></tr></table></figure><h1 id="生成示例的文件结构"><a href="#生成示例的文件结构" class="headerlink" title="生成示例的文件结构"></a>生成示例的文件结构</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── app.js</span><br><span class="line">├── bin</span><br><span class="line">│   └── www</span><br><span class="line">├── package.json</span><br><span class="line">├── public</span><br><span class="line">│   ├── images</span><br><span class="line">│   ├── javascripts</span><br><span class="line">│   └── stylesheets</span><br><span class="line">│       └── style.css</span><br><span class="line">├── routes</span><br><span class="line">│   ├── index.js</span><br><span class="line">│   └── users.js</span><br><span class="line">└── views</span><br><span class="line">    ├── error.pug</span><br><span class="line">    ├── index.pug</span><br><span class="line">    └── layout.pug</span><br><span class="line"></span><br><span class="line">7 directories, 9 files</span><br></pre></td></tr></table></figure><h1 id="express-MongoDB-RestfulApi"><a href="#express-MongoDB-RestfulApi" class="headerlink" title="express + MongoDB RestfulApi"></a>express + MongoDB RestfulApi</h1><ul><li>express</li><li>mongoose</li><li>MongoDB</li></ul>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
          <category> Express </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> Node.js </tag>
            
            <tag> Express </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>持续集成服务Travis CI</title>
      <link href="/Blog/2020/03/23/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E6%9C%8D%E5%8A%A1Travis-CI/"/>
      <url>/Blog/2020/03/23/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E6%9C%8D%E5%8A%A1Travis-CI/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是Travis"><a href="#什么是Travis" class="headerlink" title="什么是Travis"></a>什么是Travis</h1><p>为了提高软件开发效率而诞生的，构建和测试的自动化工具。</p><p><img src="https://raw.githubusercontent.com/CoryLiu/Img-repo/master/img/20200323205340.png" alt=""></p><blockquote><p><a href="http://www.ruanyifeng.com/blog/2017/12/travis_ci_tutorial.html" target="_blank" rel="noopener">引用</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
          <category> Travis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Github </tag>
            
            <tag> Travis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js基础知识回忆与巩固</title>
      <link href="/Blog/2020/03/12/js%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%9B%9E%E5%BF%86%E4%B8%8E%E5%B7%A9%E5%9B%BA/"/>
      <url>/Blog/2020/03/12/js%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%9B%9E%E5%BF%86%E4%B8%8E%E5%B7%A9%E5%9B%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="1：Vue-nextTick特性"><a href="#1：Vue-nextTick特性" class="headerlink" title="1：Vue nextTick特性"></a>1：Vue nextTick特性</h1><blockquote><p>以下内容来自 <a href="https://cn.vuejs.org/v2/api/#Vue-nextTick" target="_blank" rel="noopener">vue2.x 官方文档</a></p></blockquote><h2 id="Vue-nextTrick-callback-context"><a href="#Vue-nextTrick-callback-context" class="headerlink" title="Vue.nextTrick([callback,context])"></a>Vue.nextTrick([callback,context])</h2><ul><li>参数：<ul><li><font color=red>{Function} [callback]</font></li><li><font color=red>{Object} [context]</font></li></ul></li><li>用法：<br>在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更行后的DOM<a id="more"></a><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      msg: <span class="string">'hello'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  created () &#123;</span><br><span class="line">    <span class="keyword">this</span>.initData()</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    initData () &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'initData'</span>)</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.msg = <span class="string">'修改msg的值'</span></span><br><span class="line">        <span class="comment">// DOM 还没有更新</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>) <span class="comment">//使用箭头函数，this指向vue组件实例</span></span><br><span class="line">        <span class="keyword">this</span>.$nextTick(<span class="function"><span class="params">()</span>=&gt;</span> &#123;</span><br><span class="line">          <span class="comment">//DOM 更新了</span></span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">`触发了nextTrick的回调函数,msg的值已经修改,当前msg的值： <span class="subst">$&#123;<span class="keyword">this</span>.msg&#125;</span>`</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="comment">// Promise写法</span></span><br><span class="line">        <span class="keyword">this</span>.$nextTick()</span><br><span class="line">          .then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="comment">//DOM更新了</span></span><br><span class="line">          &#125;)</span><br><span class="line">      &#125;, <span class="number">3000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="需要使用nextTick的场景"><a href="#需要使用nextTick的场景" class="headerlink" title="需要使用nextTick的场景"></a>需要使用nextTick的场景</h2><p>当设置 vm.someData = ‘new value’ 时，组件不会立即重更新渲染。当你刷新队列时，组件会在下一个事件循环“tick”中更新。当需要用更新后的DOM来做点什么的时候，比如重新加载JQuery插件…   为了在数据变化之后等待 Vue 完成更新DOM，可以在数据变化之后立即使用 <code>Vue.nextTick(callback)</code> 。这样回调函数将在DOM更新完成后被调用。</p><ul><li>更多内容： <a href="https://cn.vuejs.org/v2/guide/reactivity.html#%E5%BC%82%E6%AD%A5%E6%9B%B4%E6%96%B0%E9%98%9F%E5%88%97" target="_blank" rel="noopener">异步更新队列</a><h2 id="继续了解Vue响应式原理"><a href="#继续了解Vue响应式原理" class="headerlink" title="继续了解Vue响应式原理"></a>继续了解Vue响应式原理</h2><img src="https://raw.githubusercontent.com/CoryLiu/Img-repo/master/img/data.jpg" alt=""><h2 id="检测变化的注意事项"><a href="#检测变化的注意事项" class="headerlink" title="检测变化的注意事项"></a>检测变化的注意事项</h2><strong>Vue无法检测到对象属性的添加或删除</strong>。因为Vue在初始化实例时对属性执行 getter/setter 转化，所以属性必须在 <code>data</code> 对象上存在才能让 Vue 将它转换为响应式。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  data:&#123;</span><br><span class="line">    a:<span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// `vm.a` 是响应式的</span></span><br><span class="line"></span><br><span class="line">vm.b = <span class="number">2</span></span><br><span class="line"><span class="comment">// `vm.b` 是非响应式的</span></span><br></pre></td></tr></table></figure><p>对于已经创建的实例，Vue 不允许动态添加根级别的响应式属性。<br>可以使用 <font color=red>Vue.set(object, propertyName, value)</font> 方法向嵌套对象添加响应式属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">      el: <span class="string">'#app'</span>,</span><br><span class="line">      data: &#123;</span><br><span class="line">        msg: <span class="string">'hello'</span>,</span><br><span class="line">        obj: &#123;</span><br><span class="line">          a: <span class="number">1</span>,</span><br><span class="line">          b: <span class="number">3</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      beforeCreate: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">      &#125;,</span><br><span class="line">      created: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.a = <span class="number">2</span></span><br><span class="line">      &#125;,</span><br><span class="line">      methods: &#123;</span><br><span class="line">        change() &#123;</span><br><span class="line">          <span class="keyword">this</span>.$<span class="keyword">set</span>(this.obj, 'c', 444) //DOM将会更新</span><br><span class="line">          //this.obj.c = 444 //不会更新DOM</span><br><span class="line">          this.$nextTick()</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><h1 id="2：前端常见的内存泄漏问题"><a href="#2：前端常见的内存泄漏问题" class="headerlink" title="2：前端常见的内存泄漏问题"></a>2：前端常见的内存泄漏问题</h1><h2 id="三种类型的常见-JavaScript-内存泄漏"><a href="#三种类型的常见-JavaScript-内存泄漏" class="headerlink" title="三种类型的常见 JavaScript 内存泄漏"></a>三种类型的常见 JavaScript 内存泄漏</h2><ol><li><p>意外的全局变量<br>未定义的变量会在全局对象创建一个新变量</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">arg</span>)</span>&#123;</span><br><span class="line">  bar = <span class="string">"this is a hidden global variable"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数 foo 内部忘记使用 var ，意外创建了一个全局变量。此例泄漏了一个简单的字符串，无伤大雅，但是有更糟的情况。<br>另一种意外的全局变量可能由 this 创建：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">this</span>.variable = <span class="string">"potential accidental global"</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// Foo 调用自己，this 指向了全局对象（window）</span></span><br><span class="line"> <span class="comment">// 而不是 undefined</span></span><br><span class="line"> foo();</span><br></pre></td></tr></table></figure><blockquote><p>在 JavaScript 文件头部加上 ‘use strict’，可以避免此类错误发生。启用严格模式解析 JavaScript ，避免意外的全局变量。   </p></blockquote><p>尽管我们讨论了一些意外的全局变量，但是仍有一些明确的全局变量产生的垃圾。它们被定义为不可回收（除非定义为空或重新分配）。尤其当全局变量用于临时存储和处理大量信息时，需要多加小心。如果必须使用全局变量存储大量数据时，确保用完以后把它设置为 null 或者重新定义。与全局变量相关的增加内存消耗的一个主因是缓存。缓存数据是为了重用，缓存必须有一个大小上限才有用。高内存消耗导致缓存突破上限，因为缓存内容无法被回收。</p></li><li><p>被遗忘的计时器或回调函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> someResource = getData();</span><br><span class="line"> setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="keyword">var</span> node = <span class="built_in">document</span>.getElementById(<span class="string">'Node'</span>);</span><br><span class="line">     <span class="keyword">if</span>(node) &#123;</span><br><span class="line">         <span class="comment">// 处理 node 和 someResource</span></span><br><span class="line">         node.innerHTML = <span class="built_in">JSON</span>.stringify(someResource));</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure></li><li><p>脱离 DOM 的引用<br>有时，保存 DOM 节点内部数据结构很有用。假如你想快速更新表格的几行内容，把每一行 DOM 存成字典（JSON 键值对）或者数组很有意义。此时，同样的 DOM 元素存在两个引用：一个在 DOM 树中，另一个在字典中。将来你决定删除这些行时，需要把两个引用都清除。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> elements = &#123;</span><br><span class="line"> button: <span class="built_in">document</span>.getElementById(<span class="string">'button'</span>),</span><br><span class="line"> image: <span class="built_in">document</span>.getElementById(<span class="string">'image'</span>),</span><br><span class="line"> text: <span class="built_in">document</span>.getElementById(<span class="string">'text'</span>)</span><br><span class="line"> &#125;;</span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">doStuff</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     image.src = <span class="string">'http://some.url/image'</span>;</span><br><span class="line">     button.click();</span><br><span class="line">     <span class="built_in">console</span>.log(text.innerHTML);</span><br><span class="line">     <span class="comment">// 更多逻辑</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">removeButton</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="comment">// 按钮是 body 的后代元素</span></span><br><span class="line">     <span class="built_in">document</span>.body.removeChild(<span class="built_in">document</span>.getElementById(<span class="string">'button'</span>));</span><br><span class="line">     <span class="comment">// 此时，仍旧存在一个全局的 #button 的引用</span></span><br><span class="line">     <span class="comment">// elements 字典。button 元素仍旧在内存中，不能被 GC 回收。</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>此外还要考虑 DOM 树内部或子节点的引用问题。假如你的 JavaScript 代码中保存了表格某一个 <code>&lt;td&gt;</code> 的引用。将来决定删除整个表格的时候，直觉认为 GC 会回收除了已保存的 <code>&lt;td&gt;</code> 以外的其它节点。实际情况并非如此：此 <code>&lt;td&gt;</code> 是表格的子节点，子元素与父元素是引用关系。由于代码保留了 <code>&lt;td&gt;</code> 的引用，导致整个表格仍待在内存中。保存 DOM 元素引用的时候，要小心谨慎。</p></li><li><p>闭包<br>闭包是 JavaScript 开发的一个关键方面：匿名函数可以访问父级作用域的变量</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> theThing = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">var</span> replaceThing = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> originalThing = theThing;</span><br><span class="line">  <span class="keyword">var</span> unused = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (originalThing)</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"hi"</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  theThing = &#123;</span><br><span class="line">    longStr: <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1000000</span>).join(<span class="string">'*'</span>),</span><br><span class="line">    someMethod: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(someMessage);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line">setInterval(replaceThing, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>代码片段做了一件事情：每次调用 <code>replaceThing</code> ，<code>theThing</code> 得到一个包含一个大数组和一个新闭包（<code>someMethod</code>）的新对象。同时，变量 <code>unused</code> 是一个引用 <code>originalThing</code> 的闭包（先前的 <code>replaceThing</code> 又调用了 <code>theThing</code> ）。思绪混乱了吗？最重要的事情是，闭包的作用域一旦创建，它们有同样的父级作用域，作用域是共享的。<code>someMethod</code> 可以通过 <code>theThing</code> 使用，<code>someMethod</code> 与 <code>unused</code> 分享闭包作用域，尽管 <code>unused</code> 从未使用，它引用的 <code>originalThing</code> 迫使它保留在内存中（防止被回收）。当这段代码反复运行，就会看到内存占用不断上升，垃圾回收器（<code>GC</code>）并无法降低内存占用。本质上，闭包的链表已经创建，每一个闭包作用域携带一个指向大数组的间接的引用，造成严重的内存泄漏。</p><blockquote><p>解决方法：在 <code>replaceThing</code> 的最后添加 <code>originalThing = null</code> 。</p></blockquote></li></ol><h1 id="3：vue-angular-react框架各自的优缺点"><a href="#3：vue-angular-react框架各自的优缺点" class="headerlink" title="3：vue, angular, react框架各自的优缺点"></a>3：vue, angular, react框架各自的优缺点</h1><ol><li><p>React：由Fackbook创建的JavaScript UI框架。React推广了VirtualDOM并创造了新语法——JSX，JSX允许开发者在JavaScript中书写HTML。</p></li><li><p>Vue：Vue致力解决的问题与React一致，解决方案不同。Vue使用模板系统而不是JSX，因为模板用的是普通的HTML，所以通过Vue对现有系统的升级更加容易，不需要整体重构。</p><h2 id="相似之处"><a href="#相似之处" class="headerlink" title="相似之处"></a>相似之处</h2><p>React与Vue存在很多相似之处，例如他们都是JavaScript的UI框架，专注于创造前端的富应用。不同于早期的JavaScript框架“功能齐全”，Reat与Vue只有框架的骨架，其他的功能如路由、状态管理等是框架分离的组件。</p><h3 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h3><p>React与Vue都鼓励组件化应用。这本质上说，是建议你将你的应用分拆成一个个功能明确的模块，每个模块之间可以通过合适的方式互相联系。</p><h2 id="不同"><a href="#不同" class="headerlink" title="不同"></a>不同</h2><p>React和Vue在实现VirtualDOM转换为真实DOM的实现方式不同。<br>Vue在渲染过程中，会跟踪每一个组件的依赖关系，不需要重新渲染整个组件树。<br>React，当应用的状态被修改时，全部子组件都会重新渲染。当然，这可以通过shouldComponentUpdate这个生命周期方法来进行控制，但Vue将此视为默认的优化。</p><h3 id="构建工具"><a href="#构建工具" class="headerlink" title="构建工具"></a>构建工具</h3><p>React可以使用Create React App (CRA)<br>Vue对应的则是vue-cli</p><h3 id="配套框架"><a href="#配套框架" class="headerlink" title="配套框架"></a>配套框架</h3><p> Vue与React最后一个相似但略有不同之处是它们配套框架的处理方法。相同之处在于，两个框架都专注于UI层，其他的功能如路由、状态管理等都交由同伴框架进行处理。</p><p> 而不同之处是在于它们如何关联它们各自的配套框架。Vue的核心团队维护着vue-router和vuex，它们都是作为官方推荐的存在。而React的react-router和react-redux则是由社区成员维护，它们都不是官方维护的。</p></li></ol><h1 id="4：前端安全问题，SQL注入，跨域安全，以及其实现原理"><a href="#4：前端安全问题，SQL注入，跨域安全，以及其实现原理" class="headerlink" title="4：前端安全问题，SQL注入，跨域安全，以及其实现原理"></a>4：前端安全问题，SQL注入，跨域安全，以及其实现原理</h1><ul><li>攻击类型<ul><li>XSS (Cross Site Script) 跨站脚本攻击</li><li>CSRF 跨站请求伪造</li><li>SQL注入</li><li>点击劫持</li><li>中间人攻击<h2 id="XSS-跨站脚本攻击"><a href="#XSS-跨站脚本攻击" class="headerlink" title="XSS 跨站脚本攻击"></a>XSS 跨站脚本攻击</h2></li></ul></li><li>定义<br>是指恶意攻击者利用网站没有对用户提交数据进行<code>转义处理</code>或者<code>过滤不足</code>的缺点，进而添加一些代码，嵌入到web页面中去。使得别的用户访问都会执行相应的嵌入代码。<br>从而盗取用户资料，利用用户身份进行某种动作或者对访问者进行病毒式侵害的一种攻击方式。</li><li>攻击类型<ul><li>反射型：<ul><li>把用户输入的数据反射给浏览器端，攻击者诱使用户点击恶意链接，或者提交一个表单或者进入一个恶意网站，注入脚本进入会被攻击者的网站，可以获取用户隐私数据（如cookie）的脚本。</li></ul></li><li>存储型：<ul><li>把用户输入的数据存储在服务器端，当浏览器请求数据时，脚本从服务器上传回并执行。这种XSS攻击具有很强的稳定性。</li><li>场景：攻击者在论坛上写下一遍包含恶意JavaScript文章或评论，文章或评论发表后，所有访问该文章或评论的用户，都会在它们的浏览器中执行这段恶意的JavaScript代码。</li></ul></li><li>基于DOM：<ul><li>通过恶意脚本修改页面的DOM结构，是纯粹发生在客户端的攻击。</li></ul></li></ul></li><li>XSS防御<ul><li>HttpOnly防止截取cookie</li><li>输入检查<ul><li>不要相信用户的任何输入。对用户的任何输入进行检查、过滤和转义。建立可信任的字符和HTML标签白名单，对于不在白名单之列的字符或者标签进行过滤或编码。<blockquote><p>在使用vue的 v-html 的时候需要注意，比如文章内容，这些是用户填写的，不可以直接渲染显示(用户可能会使用<code>&lt;script src&gt;</code>导致看这个文章的人会加载外站js从而做些不可控的事情)。</p></blockquote></li></ul></li></ul></li></ul><p>可以使用 <code>xss</code> 模块进行防御 <code>v-html=$xss(test)</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;p v-html=<span class="string">"$xss(test)"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> xss <span class="keyword">from</span> <span class="string">'xss'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      test: <span class="string">`&lt;a onclick='alert("xss攻击")'&gt;链接&lt;/a&gt;`</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">Object</span>.defineProperty(Vue.prototype, <span class="string">'$xss'</span>, &#123;</span><br><span class="line">  value: xss</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="跨站请求伪造-CSRF"><a href="#跨站请求伪造-CSRF" class="headerlink" title="跨站请求伪造 CSRF"></a>跨站请求伪造 CSRF</h2><ul><li><p>攻击原理</p><ul><li>用户登录A网站</li><li>A网站确认身份，给客户端cookie</li><li>用户在没有退出A网站的情况下，访问B网站</li><li>B网站页面向A网站发起一个请求</li><li>根据B的请求，浏览器带着产生的Cookie访问A</li></ul></li><li><p>防御方法</p><ul><li>GET请求不对数据进行修改</li><li>不让第三方网站访问到用户的cookie<ul><li>SameSite<ul><li>可以对cookie设置SameSite属性。该属性设置cookie不随着跨域请求发送，该属性可以很大程度减少跨站请求伪造，但是该属性目前并不是所有浏览器都兼容。</li></ul></li></ul></li><li>防止第三方网站请求接口<ul><li>Refere验证<ul><li>通过验证Refere来判断该请求是否是第三方网站发起的，在后台接到请求的时候，可以通过请求头中的Refere请求头来判断请求来源。</li><li>使用场景：不仅防范跨站请求伪造，还可以防止图片盗链</li></ul></li><li>请求时附带验证信息，比如验证码或者Token<ul><li>验证码<ul><li>跨站请求伪造攻击往往是在用户不知情的情况下构造了网络请求，而验证码会强制用户必须与应用进行交互，才能完成最终请求。</li></ul></li><li>添加Token验证<ul><li>服务器下发一个随机Token，每次发起请求时将Token携带上，服务器建立拦截器验证Token是否有效。</li></ul></li></ul></li></ul></li></ul><p><strong>跟跨网站脚本（XSS）相比，XSS 利用的是用户对指定网站的信任，CSRF 利用的是网站对用户网页浏览器的信任。</strong></p></li></ul><h2 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h2><ul><li>定义：<ul><li>就是通过把SQL命令插入到WEB表单提交或输入域名或页面请求的查询字符串，后台执行SQL语句时直接把前端传入的字段拿来做SQL查询。</li></ul></li><li>防御：<ul><li>不要使用动态SQL<ul><li>避免将用户提供的输入直接放入SQL语句中</li><li>最好使用准备好的语句和参数化查询，这样更安全</li></ul></li><li>不要把敏感数据保留在纯文本中<ul><li>加密存储在数据库中的私有/机密数据</li><li>这样可以提供了另一级保护，以防攻击者成功地排出敏感数据。</li></ul></li><li>限制数据库权限和特权<ul><li>将数据库用户的功能设置为最低要求</li><li>这将限制攻击者在设法获取权限时可以执行的操作</li></ul></li><li>避免直接向用户显示数据库错误<ul><li>攻击者可以使用这些错误消息来获取有关数据库的信息</li></ul></li><li>对访问数据库的WEB应用程序使用WEB应用程序防火墙（WAF）<ul><li>这为面向Web的应用程序提供了保护，它可以帮助识别SQL注入尝试</li><li>根据设置，它还可以帮助防止SQL注入尝试到应用程序（以及数据库）</li></ul></li><li>定期测试与数据交互的Web应用程序<ul><li>这样做可以帮助捕获可能允许的SQL注入的新错误或回归</li></ul></li><li>将数据库更新为最新的的可用修补程序<ul><li>这可以防止攻击者利用旧版本存在的已知弱点/错误</li></ul></li></ul></li></ul><h2 id="点击劫持"><a href="#点击劫持" class="headerlink" title="点击劫持"></a>点击劫持</h2><ul><li>原理：点击劫持是一种视觉欺骗的攻击手段，攻击者将需要攻击的网站通过iframe嵌套的方式嵌入到自己的网页中，并将iframe设置为透明，在页面中透出一个按钮诱导用户点击。</li><li>防御方法：<ul><li>X-FRAME-OPTIONS</li><li>Js防御 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// css中设置 body&#123;display:none !important;&#125;</span></span><br><span class="line"> <span class="keyword">if</span>(self == top) &#123; <span class="comment">// window.top是读取窗口的引用    window.top是顶层窗口</span></span><br><span class="line">        <span class="built_in">document</span>.getElementsByTagName(<span class="string">'body'</span>)[<span class="number">0</span>].style.display = <span class="string">'block'</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        top.location = self.location; <span class="comment">//;localtion：该对象包含当前URL信息 拥有多个属性</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="中间人攻击"><a href="#中间人攻击" class="headerlink" title="中间人攻击"></a>中间人攻击</h2></li></ul></li><li>原理：<ul><li>中间人攻击是攻击方同时与服务端和客户端建立起了连接，并让双方认为连接是安全的，但是实际上整个通信都被攻击者控制了。</li><li>攻击者不仅能获得双方的通信信息，还能修改通信信息。</li></ul></li></ul><h1 id="5：跨域的所有解决方案"><a href="#5：跨域的所有解决方案" class="headerlink" title="5：跨域的所有解决方案"></a>5：跨域的所有解决方案</h1><blockquote><p><a href="https://segmentfault.com/a/1190000011145364" target="_blank" rel="noopener">详细引用文章</a></p></blockquote><h2 id="需要跨域的原因"><a href="#需要跨域的原因" class="headerlink" title="需要跨域的原因"></a>需要跨域的原因</h2><p>浏览器的 <code>同源策略</code> SOP (same orgin policy) ，是浏览器核心最基本的安全功能。<br>所谓同源是指 <code>&quot;协议+域名+端口&quot;</code> 三者相同，即便两个不同的域名指向同一个ip地址，也非同源。</p><h2 id="跨域解决方案"><a href="#跨域解决方案" class="headerlink" title="跨域解决方案"></a>跨域解决方案</h2><ol><li>jsonp</li><li>document.domain + iframe跨域</li><li>location.hash + iframe跨域</li><li>window.name + iframe跨域</li><li>postMessage跨域</li><li>跨域资源共享（CORS）</li><li>nginx代理跨域</li><li>nodejs 中间件代理跨域</li><li>WebSocket协议跨域<h2 id="jsonp跨域"><a href="#jsonp跨域" class="headerlink" title="jsonp跨域"></a>jsonp跨域</h2>缺点：只能实现get请求跨域<h2 id="iframe的三种跨域"><a href="#iframe的三种跨域" class="headerlink" title="iframe的三种跨域"></a>iframe的三种跨域</h2><h2 id="postMessage跨域"><a href="#postMessage跨域" class="headerlink" title="postMessage跨域"></a>postMessage跨域</h2><h2 id="跨域资源共享（CORS）"><a href="#跨域资源共享（CORS）" class="headerlink" title="跨域资源共享（CORS）"></a>跨域资源共享（CORS）</h2>普通跨域请求：服务端设置Access-Control-Allow-Origin即可，前端无须设置，若要带cookie请求：前后端都需要设置。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前端设置是否带cookie</span></span><br><span class="line">withCredentials = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><h2 id="nginx代理跨域"><a href="#nginx代理跨域" class="headerlink" title="nginx代理跨域"></a>nginx代理跨域</h2>nginx配置<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">81</span>;</span><br><span class="line">    <span class="attribute">server_name</span>  www.domain1.com;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span>   http://www.domain2.com:8080;  <span class="comment">#反向代理</span></span><br><span class="line">        <span class="attribute">proxy_cookie_domain</span> www.domain2.com www.domain1.com; <span class="comment">#修改cookie里域名</span></span><br><span class="line">        <span class="attribute">index</span>  index.html index.htm;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用</span></span><br><span class="line">        <span class="attribute">add_header</span> Access-Control-Allow-Origin http://www.domain1.com;  <span class="comment">#当前端只跨域不带cookie时，可为*</span></span><br><span class="line">        <span class="attribute">add_header</span> Access-Control-Allow-Credentials <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="WebSocket协议跨域"><a href="#WebSocket协议跨域" class="headerlink" title="WebSocket协议跨域"></a>WebSocket协议跨域</h2>关键词：Scoket.io模块</li></ol><h1 id="6：前端项目的性能优化"><a href="#6：前端项目的性能优化" class="headerlink" title="6：前端项目的性能优化"></a>6：前端项目的性能优化</h1><p>前端项目的性能优化手段，如果都罗列出来，可以写一本书了。。。<br>暂时记录几个原则，日后在实际项目中遇到对应的情况再详细补充笔记   </p><ul><li>请求数量——合并脚本和样式表，CSS Sprites，拆分初始化负载，划分主域</li><li>请求带宽——开启Gzip，精简JavaScript，移除重复脚本，图像优化</li><li>缓存利用——使用CDN，使用外部JavaScript和CSS，添加Expires头，减少DNS查找，配置ETag，使Ajax可缓存</li><li>页面结构——将样式表放在顶部，将脚本放在底部，尽早刷新文档的输出</li><li>代码校验——避免CSS表达式，避免重定向</li></ul><h2 id="WebP图片格式"><a href="#WebP图片格式" class="headerlink" title="WebP图片格式"></a>WebP图片格式</h2><h2 id="vue项目中，将小图片直接转化base64，减少请求"><a href="#vue项目中，将小图片直接转化base64，减少请求" class="headerlink" title="vue项目中，将小图片直接转化base64，减少请求"></a>vue项目中，将小图片直接转化base64，减少请求</h2><h2 id="优化项目的切入点"><a href="#优化项目的切入点" class="headerlink" title="优化项目的切入点"></a>优化项目的切入点</h2><ul><li>减少客户端请求</li><li>减少服务器端响应的体积（如gzip压缩）</li><li>客户端优化 dom，css，js的代码加载顺序；或使用服务器端渲染，减少客户端渲染压力（vue中的 <code>ssr</code> 技术。<a href="https://cn.vuejs.org/v2/guide/ssr.html" target="_blank" rel="noopener">相关链接</a>）</li><li>网络优化，比如增加 CDN 缓存；或增加并发处理能力，比如服务端设置多个域名，客户端使用多个域名同时请求资源，增加并发量。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>笔记-JavaScript判断数据类型的方法总结</title>
      <link href="/Blog/2020/03/11/%E7%AC%94%E8%AE%B0-JavaScript%E5%88%A4%E6%96%AD%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"/>
      <url>/Blog/2020/03/11/%E7%AC%94%E8%AE%B0-JavaScript%E5%88%A4%E6%96%AD%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="1-typeof"><a href="#1-typeof" class="headerlink" title="1: typeof"></a>1: typeof</h1><p><code>typeof</code> 操作符返回一个<code>字符串</code>，表示未经计算的操作数的类型。</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><blockquote><p>typeof operand<br>typeof(operand)</p></blockquote><p> <em>注: operand [ˈɑːpərænd] n. [计] 操作数</em></p> <a id="more"></a><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p><strong>operand</strong></p><p>一个表示对象或原始值的表达式，其类型将被返回</p><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><table><thead><tr><th>类型</th><th>结果</th></tr></thead><tbody><tr><td>Undefined</td><td>“undefined”</td></tr><tr><td>Null</td><td>“object”</td></tr><tr><td>Boolean</td><td>“boolean”</td></tr><tr><td>Number</td><td>“number”</td></tr><tr><td>BigInt <a href="https://zhuanlan.zhihu.com/p/36330307" target="_blank" rel="noopener">详细</a></td><td>“bigint”</td></tr><tr><td>String</td><td>“string”</td></tr><tr><td>Symbol(ES2015新增的数据类型)</td><td>“symbol”</td></tr><tr><td>Function对象</td><td>“function”</td></tr><tr><td>其他任何对象</td><td>“object”</td></tr></tbody></table><h2 id="注意！！！-null"><a href="#注意！！！-null" class="headerlink" title="注意！！！ null"></a>注意！！！ null</h2><blockquote><p>typeof null === ‘object’;</p></blockquote><p>在 JavaScript 最初的实现中，JavaScript 中的值是由一个表示类型的标签和实际数据值表示的。对象的类型标签是 0。由于 null 代表的是空指针（大多数平台下值为 0x00），因此，null 的类型标签是 0，typeof null 也因此返回 “object”。</p><p>曾有一个 ECMAScript 的修复提案（通过选择性加入的方式），但被拒绝了。该提案会导致 typeof null === ‘null’。</p><h2 id="new"><a href="#new" class="headerlink" title="new"></a>new</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 除 Function 外的所有构造函数的类型都是 'object'</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'String'</span>);</span><br><span class="line"><span class="keyword">var</span> num = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> str; <span class="comment">// 返回 'object'</span></span><br><span class="line"><span class="keyword">typeof</span> num; <span class="comment">// 返回 'object'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> func = <span class="keyword">new</span> <span class="built_in">Function</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> func; <span class="comment">// 返回 'function'</span></span><br></pre></td></tr></table></figure><h1 id="2-toString"><a href="#2-toString" class="headerlink" title="2: toString"></a>2: toString</h1><p>toString 是 object 的原型方法，调用该方法，默认返回当前对象的 Class 。<br>对于 Object 对象，直接调用 toString()  就能返回 [object Object] 。而对于其他对象，则需要通过 call / apply 来调用才能返回正确的类型信息。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="string">''</span>) ;   <span class="comment">// [object String]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="number">1</span>) ;    <span class="comment">// [object Number]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">true</span>) ; <span class="comment">// [object Boolean]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">Symbol</span>()); <span class="comment">//[object Symbol]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">undefined</span>) ; <span class="comment">// [object Undefined]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">null</span>) ; <span class="comment">// [object Null]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="keyword">new</span> <span class="built_in">Function</span>()) ; <span class="comment">// [object Function]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="keyword">new</span> <span class="built_in">Date</span>()) ; <span class="comment">// [object Date]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call([]) ; <span class="comment">// [object Array]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="keyword">new</span> <span class="built_in">RegExp</span>()) ; <span class="comment">// [object RegExp]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="keyword">new</span> <span class="built_in">Error</span>()) ; <span class="comment">// [object Error]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">document</span>) ; <span class="comment">// [object HTMLDocument]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">window</span>) ; <span class="comment">//[object global] window 是全局对象 global 的引用</span></span><br></pre></td></tr></table></figure><h1 id="3-constructor"><a href="#3-constructor" class="headerlink" title="3: constructor"></a>3: constructor</h1><p>constructor 是原型 prototype 的一个属性，当函数被定义时候，js 引擎会为函数添加原型prototype，并且这个 prototype 中 constructor 属性指向函数引用， 因此重写 prototype 会丢失原来的constructor。</p><p><font color=red><strong>不过这种方法有问题：</strong></font></p><ol><li>null 和 undefined 无constructor，这种方法判断不了。</li><li>如果自定义对象，开发者重写prototype之后，原有的constructor会丢失，因此，为了规范开发，在重写对象原型时一般都需要重新给 constructor 赋值，以保证对象实例的类型不被篡改。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">''</span>.constructor === <span class="built_in">String</span> <span class="comment">//true</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">1</span>).constructor === <span class="built_in">Number</span> <span class="comment">//true</span></span><br><span class="line"><span class="literal">true</span>.constructor === <span class="built_in">Boolean</span> <span class="comment">//true</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Function</span>().constructor === <span class="built_in">Function</span> <span class="comment">//true</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>().constructor === <span class="built_in">Date</span> <span class="comment">//true</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Error</span>().constructor === <span class="built_in">Error</span> <span class="comment">//true</span></span><br><span class="line">[].constructor === <span class="built_in">Array</span> <span class="comment">//true</span></span><br><span class="line"><span class="built_in">document</span>.constructor === HTMLDocument <span class="comment">//true</span></span><br><span class="line"><span class="built_in">window</span>.constructor === Window <span class="comment">//true</span></span><br></pre></td></tr></table></figure><h1 id="4-instanceof"><a href="#4-instanceof" class="headerlink" title="4:instanceof"></a>4:instanceof</h1><p>字面翻译理解，<code>instance</code> 实例，即<br>instanceof 是用来判断 A 是否为 B 的实例，表达式为：A instanceof B，如果 A 是 B 的实例，则返回 true,否则返回 false。 在这里需要特别注意的是：instanceof 检测的是原型</p><p><img src="https://raw.githubusercontent.com/CoryLiu/Img-repo/master/img/%E6%8D%95%E8%8E%B7.JPG" alt=""></p><p>[]的原型指向 Array.prototype, 间接指向 Object.prototype</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[] <span class="keyword">instanceof</span> <span class="built_in">Array</span> === <span class="literal">true</span> <span class="comment">//true</span></span><br><span class="line">[] <span class="keyword">instanceof</span> <span class="built_in">Object</span> === <span class="literal">true</span> <span class="comment">//也是true</span></span><br></pre></td></tr></table></figure><p>所以 instanceof 只能用来判断两个对象是否属于实例关系， 而不能判断一个对象实例具体属于哪种类型。（JavaScript特殊的原型链机制）</p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>less,sass,scss笔记</title>
      <link href="/Blog/2020/03/08/less-sass-scss%E7%AC%94%E8%AE%B0/"/>
      <url>/Blog/2020/03/08/less-sass-scss%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="前言（css预处理器）"><a href="#前言（css预处理器）" class="headerlink" title="前言（css预处理器）"></a>前言（css预处理器）</h2><p>好多年前，从使用bootstrap开始，就接触过less<br>随着这些年前端技术的发展，现在越来越多的 <code>css预处理器</code> 被创造出来，web开发中，美工设计将不再是从前那种切图，然后生成冗长而又难以维护的css代码了<br>其实在我的理解看来，不论是less，sass，scss还是stylus，他们的诞生就是为了让css的编写更“程序化”，就像规定了一套约定和语法，然后可以通过解释与编译成css（最终生成的必定还是css，因为浏览器只认识css啊）<br>写下这篇笔记，梳理一下css预处理器的基础知识，方便之后自己查看</p><a id="more"></a><h2 id="sass"><a href="#sass" class="headerlink" title="sass"></a>sass</h2><p>按时间顺序来说，sass应该是最早出现的css预处理器   </p><blockquote><p>维基百科：Sass（英文全称：Syntactically Awesome Stylesheets）是一个最初由Hampton Catlin设计并由Natalie Weizenbaum开发的层叠样式表语言。在开发最初版本之后，Weizenbaum和Chris Eppstein继续通过SassScript来继续扩充Sass的功能。SassScript是一个在Sass文件中使用的小型脚本语言。</p></blockquote><p>在我的理解，sass和scss其实都属于sass。最初的sass是以换行和缩进来进行书写，看起来更接近于ruby，python的感觉，文件后缀 .sass 。而后又诞生了新的语法“scss”，文件后缀 .scss，相比sass，scss的语法更接近css，因为使用花括号作为分隔。而且scss完全兼容css，这就意味着，你可以直接复制从前的css到新的.scss文件中。</p><h2 id="less"><a href="#less" class="headerlink" title="less"></a>less</h2><p>2009年出现，受SASS的影响较大，但又使用CSS的语法，让大部分开发者和设计师更容易上手，在ruby社区之外支持者远超过SASS，其缺点是比起SASS来，可编程功能不够，不过优点是简单和兼容CSS，反过来也影响了SASS演变到了SCSS的时代，著名的Twitter Bootstrap就是采用LESS做底层语言的。</p><h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><blockquote><p><a href="http://lesscss.org/" target="_blank" rel="noopener">less官网</a></p></blockquote><blockquote><p><a href="https://www.sass.hk/" target="_blank" rel="noopener">sass中文网</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于前端工程化的理解</title>
      <link href="/Blog/2020/02/27/%E5%85%B3%E4%BA%8E%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E7%9A%84%E7%90%86%E8%A7%A3/"/>
      <url>/Blog/2020/02/27/%E5%85%B3%E4%BA%8E%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E7%9A%84%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>春节期间，太久没有动手写代码，不但生疏了基础知识，连理论概念都说不出来，今天静下心来，简单总结一下</p><h2 id="什么是前端工程化"><a href="#什么是前端工程化" class="headerlink" title="什么是前端工程化"></a>什么是前端工程化</h2><p>随着web业务日益复杂化和多元化，从前的前端，只是“做网页”“WebPage”而已，而如今，更像是在做一个“WebApp”。而且更多时候的需求也要求是单页面应用，这样对用户的体验会更佳，与传统的客户端程序或手机app一样。所以，前端开发，现在终于可以称得上是“软件开发”了。</p><a id="more"></a><p>既然是软件开发，那么就要有软件工程的概念：</p><ul><li>如何进行多人协作</li><li>如何保证项目的可维护性</li><li>如何让项目的开发流程可控</li><li>…</li></ul><p>总的来说，前端开发工程化就是使用软件工程技术和方法进行前端的开发流程，技术，工具，经验等规范化，标准化。<br>其实主要目的都是为了提高开发效率，降低维护成本，前端工程也可以是软件工程的一种。</p><ul><li>软件工程的定义是: “应用计算机科学理论和技术以及工程管理原则和方法，按预算和进度，实现满足用户要求的软件产品的定义、开发、和维护的工程或进行研究的学科”（GB/T11457-2006《信息技术 软件工程术语》）。</li></ul><h2 id="前端工程化具体是如何实现的"><a href="#前端工程化具体是如何实现的" class="headerlink" title="前端工程化具体是如何实现的"></a>前端工程化具体是如何实现的</h2><p>近些年，node.js的发展给前端工程化创造了条件，主要包含四个方面。“模块化”，“组件化”，“规范化”，“自动化”</p><h1 id="1：模块化"><a href="#1：模块化" class="headerlink" title="1：模块化"></a>1：模块化</h1><blockquote><p>简单来说，模块化就是把一个大文件按功能，按业务逻辑分成相互依赖的小文件，再统一拼装和加载</p></blockquote><h2 id="js的模块化"><a href="#js的模块化" class="headerlink" title="js的模块化"></a>js的模块化</h2><p>在ES6之前，JavaScript一直没有模块系统。因此大多使用CommonJS，AMD，CMD完成模块的拆分和加载</p><ol><li>用webpack+babel将所有模块打包成一个文件同步加载，也可以搭乘多个chunk异步加载；<blockquote><p>chunk表示一个文件，默认情况下webpack的输入是一个入口文件，输出也是一个文件，这个文件就是一个chunk，chunkId就是产出时给每个文件一个唯一标识id，chunkhash就是文件内容的md5值，name就是在entry中指定的key值。</p></blockquote></li><li>用++System+Babel++主要是分模块异步加载；</li><li>用浏览器的&lt;script type=”module”&gt;加载。</li></ol><h2 id="css的模块化"><a href="#css的模块化" class="headerlink" title="css的模块化"></a>css的模块化</h2><p>虽然SASS、LESS、Stylus等预处理器实现了CSS的文件拆分，但没有解决CSS模块化的一个重要问题：选择器的全局污染问题。</p><p>按道理，一个模块化的文件应该要隐藏内部作用域，只暴露少量接口给使用者。而按照目前预处理器的方式，导入一个CSS模块后，已存在的样式有被覆盖的风险。虽然重写样式是CSS的一个优势，但这并不利于多人协作。</p><p>为了避免全局选择器的冲突，需要制定CSS命名风格：</p><ul><li>BEM风格</li><li>Bootstrap风格</li><li>…<br>但是这毕竟是弱约束。所以很赞同一句话：</li></ul><blockquote><p>与其费尽心思地告诉别人要遵守某种规则，以规避某种痛苦，倒不如从工具层面就消灭这种痛苦。</p></blockquote><p>从工具层面，社区又创造出Shadow DOM、CSS in JS和CSS Modules三种解决方案。</p><ul><li>Shadow DOM是WebComponents的标准。它能解决全局污染问题，但目前很多浏览器不兼容，对我们来说还很久远；</li><li>CSS in JS是彻底抛弃CSS，使用JS或JSON来写样式。这种方法很激进，不能利用现有的CSS技术，而且处理伪类等问题比较困难；</li><li>CSS Modules仍然使用CSS，只是让JS来管理依赖。它能够最大化地结合CSS生态和JS模块化能力，目前来看是最好的解决方案。Vue的scoped style也算是一种。(vue的scope实现原理)</li></ul><h2 id="资源的模块化"><a href="#资源的模块化" class="headerlink" title="资源的模块化"></a>资源的模块化</h2><p>Webpack的强大之处不仅仅在于它统一了JS的各种模块系统，取代了Browserify、RequireJS、SeaJS的工作。更重要的是它的万能模块加载理念，即所有的资源都可以且也应该模块化。<br>资源模块化后，优点是：</p><ul><li>依赖关系单一化。所有CSS和图片等资源的依赖关系统一走JS路线，无需额外处理CSS预处理器的依赖关系，也不需处理代码迁移时的图片合并、字体图片等路径问题；</li><li>资源处理集成化。现在可以用loader对各种资源做各种事情，比如复杂的vue-loader等等；</li><li>项目结构清晰化。使用Webpack后，你的项目结构总可以表示成这样的函数： dest = webpack(src, config)。</li></ul><h1 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h1><p>从UI拆分下来的每个包含模板(HTML)+样式(CSS)+逻辑(JS)功能完备的结构单元，我们称之为组件。</p><blockquote><p>组件化≠模块化。模块化只是在文件层面上，对代码或资源的拆分；而组件化是在设计层面上，对UI（用户界面）的拆分。</p></blockquote><p>页面上所有的东西都是组件。页面是个大型组件，可以拆成若干个中型组件，然后中型组件还可以再拆，拆成若干个小型组件，小型组件也可以再拆，直到拆成DOM元素为止。DOM元素可以看成是浏览器自身的组件，作为组件的基本单元。</p><p>传统前端框架/类库的思想是先组织DOM，然后把某些可复用的逻辑封装成组件来操作DOM，是DOM优先；而组件化框架/类库的思想是先来构思组件，然后用DOM这种基本单元结合相应逻辑来实现组件，是组件优先。这是两者本质的区别。</p><p>其次，组件化实际上是一种按照模板(HTML)+样式(CSS)+逻辑(JS)三位一体的形式对面向对象的进一步抽象。</p><p>所以我们除了封装组件本身，还要合理处理组件之间的关系，比如 （逻辑）继承、（样式）扩展、（模板）嵌套和包含等，这些关系都可以归为依赖。</p><h1 id="规范化"><a href="#规范化" class="headerlink" title="规范化"></a>规范化</h1><p>规范化其实是工程化中很重要的一个部分，项目初期规范制定的好坏会直接影响到后期的开发质量。</p><p>比如：</p><ul><li><p>目录结构的制定</p><p>  目录结构的合理设定，能为项目带来很多优点：</p><ul><li>有助于提高项目的逻辑结构合理性；</li><li>对应扩展和合作；</li><li>方便资源的统一定位管理。</li></ul></li><li><p>规范编码</p><p>  制定一套良好的编码规范可以增强团队开发协作、提高代码质量。</p><p>  编码规范包括：</p><ul><li><p>HTML规范。</p><p>  基于 W3C、苹果开发者 等官方文档，并结合团队业务和开发过程中总结的规范约定，让页面HTML代码更具语义性。</p></li><li><p>CSS规范。</p><p>  统一规范团队 CSS 代码书写风格和使用 CSS 预编译语言语法风格，提供常用媒体查询语句和浏览器私有属性引用，并从业务层面统一规范常用模块的引用。</p></li><li><p>JS规范。</p><p>  统一规范团队 CSS 代码书写风格和使用 CSS 预编译语言语法风格，提供常用媒体查询语句和浏览器私有属性引用，并从业务层面统一规范常用模块的引用。</p></li><li><p>图片规范。</p><p>  了解各种图片格式特性，根据特性制定图片规范，包括但不限于图片的质量约定、图片引入方式、图片合并处理等，旨在从图片层面优化页面性能。</p></li><li><p>命名规范。</p><p>  从 目录、图片、HTML/CSS文件、ClassName 的命名等层面约定规范团队的命名习惯，增强团队代码的可读性。</p></li></ul></li><li><p>前后端接口规范</p><p>  “基于 Ajax 带来的 SPA 时代”，这种模式下，前后端的分工非常清晰，前后端的关键协作点是 Ajax 接口，引发一个重要问题：前后端的对接界面双方却关注甚少，没有任何接口约定规范情况下各自撸起袖子就是干，导致我们在产品项目开发过程中，前后端的接口联调对接工作量占比在30%-50%左右，甚至会更高。往往前后端接口联调对接及系统间的联调对接都是整个产品项目研发的软肋。</p><p>  接口规范主要初衷就是规范约定先行，尽量避免沟通联调产生的不必要的问题，让大家身心愉快地专注于各自擅长的领域。</p><p>  那么，对于这一SPA阶段，前后端分离有几个重要的关注挑战：</p><ul><li>职责分离</li></ul><ol><li><p>前后端仅仅通过异步接口(AJAX/JSONP)来编程；</p></li><li><p>前后端都各自有自己的开发流程，构建工具，测试集合；</p></li><li><p>关注点分离，前后端变得相对独立并松耦合。</p><table><thead><tr><th>后端</th><th>前端</th></tr></thead><tbody><tr><td>提供数据</td><td>接收数据，返回数据</td></tr><tr><td>处理业务逻辑</td><td>处理渲染逻辑</td></tr></tbody></table></li></ol><ul><li><p>规范原则</p><ol><li>接口返回数据即显示，前端仅做渲染逻辑处理；</li><li>渲染逻辑禁止跨多个接口调用；</li><li>前端关注交互、渲染逻辑，尽量避免业务逻辑处理的出现；</li><li>请求响应传输数据格式：JSON，JSON数据尽量简单轻量，避免多级JSON的出现；</li></ol></li><li><p>响应格式</p><ol><li>响应基本格式及处理状态值的规范。<ul><li>基本响应格式</li><li>列表响应格式</li></ul></li><li>特殊内容<ul><li>下拉框、复选框、单选框统一由后端逻辑判定选中返回给前端展示；</li><li>关于Boolean类型，JSON数据传输中一律使用1/0来标示，1为是/True，0为否/False</li><li>关于日期类型，JSON数据传输中一律使用字符串，具体日期格式因业务而定；</li></ul></li></ol></li><li><p>文档规范</p></li><li><p>组件管理</p></li><li><p>git分支管理</p></li><li><p>commit描述规范</p></li><li><p>视觉图标规范</p></li><li><p>…</p></li></ul></li></ul><h2 id="自动化"><a href="#自动化" class="headerlink" title="自动化"></a>自动化</h2><p>前端工程化的很多脏活累活都应该交给自动化工具来完成。需要秉持的一个理念是:</p><blockquote><p>任何简单机械的重复劳动都应该让机器去完成。</p></blockquote><ul><li>图标合并</li><li>持续继承</li><li>自动化构建</li><li>自动化部署</li><li>自动化测试</li></ul>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
          <category> Vue.js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记录下数组操作中的几个方法</title>
      <link href="/Blog/2020/02/11/%E8%AE%B0%E5%BD%95%E4%B8%8B%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C%E4%B8%AD%E7%9A%84%E5%87%A0%E4%B8%AA%E6%96%B9%E6%B3%95/"/>
      <url>/Blog/2020/02/11/%E8%AE%B0%E5%BD%95%E4%B8%8B%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C%E4%B8%AD%E7%9A%84%E5%87%A0%E4%B8%AA%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="关于数组"><a href="#关于数组" class="headerlink" title="关于数组"></a>关于数组</h2><p>避免使用new Array()</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> points = <span class="keyword">new</span> <span class="built_in">Array</span>();         <span class="comment">// 差</span></span><br><span class="line"><span class="keyword">var</span> points = [];                  <span class="comment">// 优</span></span><br></pre></td></tr></table></figure><p>原因：new 关键词只会使代码复杂化。它还会产生某些不可预期的结果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> points = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">40</span>, <span class="number">100</span>);  <span class="comment">// 创建包含两个元素的数组（40 和 100）</span></span><br></pre></td></tr></table></figure><p>加入只有一个元素</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> points = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">40</span>); <span class="comment">//创建了包含 40 个未定义元素的数组！！！</span></span><br></pre></td></tr></table></figure><hr><h2 id="数组操作常用方法"><a href="#数组操作常用方法" class="headerlink" title="数组操作常用方法"></a>数组操作常用方法</h2><h3 id="push"><a href="#push" class="headerlink" title="push()"></a>push()</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fruits = [<span class="string">"Banana"</span>, <span class="string">"Orange"</span>, <span class="string">"Apple"</span>, <span class="string">"Mango"</span>];</span><br><span class="line">fruits.push(<span class="string">"Kiwi"</span>);       <span class="comment">//  向 fruits 添加一个新元素</span></span><br></pre></td></tr></table></figure><h3 id="shift"><a href="#shift" class="headerlink" title="shift()"></a>shift()</h3><p>删除首个数组元素，并把所有其他元素“位移”到更低的索引。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fruits = [<span class="string">"Banana"</span>, <span class="string">"Orange"</span>, <span class="string">"Apple"</span>, <span class="string">"Mango"</span>];</span><br><span class="line">fruits.shift();            <span class="comment">// 从 fruits 删除第一个元素 "Banana"</span></span><br></pre></td></tr></table></figure><h3 id="unshift"><a href="#unshift" class="headerlink" title="unshift()"></a>unshift()</h3><p>unshift() 方法（在开头）向数组添加新元素：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fruits = [<span class="string">"Banana"</span>, <span class="string">"Orange"</span>, <span class="string">"Apple"</span>, <span class="string">"Mango"</span>];</span><br><span class="line">fruits.unshift(<span class="string">"Lemon"</span>);    <span class="comment">// 向 fruits 添加新元素 "Lemon"</span></span><br></pre></td></tr></table></figure><h3 id="splice"><a href="#splice" class="headerlink" title="splice()"></a>splice()</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fruits = [<span class="string">"Banana"</span>, <span class="string">"Orange"</span>, <span class="string">"Apple"</span>, <span class="string">"Mango"</span>];</span><br><span class="line">fruits.splice(<span class="number">2</span>, <span class="number">0</span>, <span class="string">"Lemon"</span>, <span class="string">"Kiwi"</span>);</span><br></pre></td></tr></table></figure><p>(2)表示位置<br>(0)表示从这个位置开始要删除的个数<br>其余表示要添加的元素</p><ul><li>使用splice()来删除元素<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fruits = [<span class="string">"Banana"</span>, <span class="string">"Orange"</span>, <span class="string">"Apple"</span>, <span class="string">"Mango"</span>];</span><br><span class="line">fruits.splice(<span class="number">0</span>, <span class="number">1</span>);        <span class="comment">// 删除 fruits 中的第一个元素</span></span><br></pre></td></tr></table></figure><h3 id="concat"><a href="#concat" class="headerlink" title="concat()"></a>concat()</h3>连接数组<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myGirls = [<span class="string">"Cecilie"</span>, <span class="string">"Lone"</span>];</span><br><span class="line"><span class="keyword">var</span> myBoys = [<span class="string">"Emil"</span>, <span class="string">"Tobias"</span>, <span class="string">"Linus"</span>];</span><br><span class="line"><span class="keyword">var</span> myChildren = myGirls.concat(myBoys);   <span class="comment">// 连接 myGirls 和 myBoys</span></span><br></pre></td></tr></table></figure><h3 id="slice"><a href="#slice" class="headerlink" title="slice()"></a>slice()</h3>截取数组<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fruits = [<span class="string">"Banana"</span>, <span class="string">"Orange"</span>, <span class="string">"Lemon"</span>, <span class="string">"Apple"</span>, <span class="string">"Mango"</span>];</span><br><span class="line"><span class="keyword">var</span> citrus = fruits.slice(<span class="number">1</span>); <span class="comment">// citrus:[ "Orange", "Lemon", "Apple", "Mango" ]</span></span><br></pre></td></tr></table></figure>slice() 可接受两个参数，比如 (1, 3)。<br>该方法会从开始参数选取元素，直到结束参数（不包括）为止。</li></ul><hr><h2 id="数据排序"><a href="#数据排序" class="headerlink" title="数据排序"></a>数据排序</h2><h3 id="sort-排序"><a href="#sort-排序" class="headerlink" title="sort() 排序"></a>sort() 排序</h3><p>sort() 方法以字母顺序对数组进行排序</p><h3 id="reverse-反转数组"><a href="#reverse-反转数组" class="headerlink" title="reverse() 反转数组"></a>reverse() 反转数组</h3><h3 id="sort-对数组数字进行排序"><a href="#sort-对数组数字进行排序" class="headerlink" title="sort()对数组数字进行排序"></a>sort()对数组数字进行排序</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> points = [<span class="number">40</span>, <span class="number">100</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">25</span>, <span class="number">10</span>];</span><br><span class="line">points.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>)</span>&#123;<span class="keyword">return</span> a - b&#125;);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> Array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Promise笔记</title>
      <link href="/Blog/2020/01/31/Promise%E7%AC%94%E8%AE%B0/"/>
      <url>/Blog/2020/01/31/Promise%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="使用Promise的目的"><a href="#使用Promise的目的" class="headerlink" title="使用Promise的目的"></a>使用Promise的目的</h2><p>Promise对延时和异步操作流进行控制</p><h2 id="Promise状态图"><a href="#Promise状态图" class="headerlink" title="Promise状态图"></a>Promise状态图</h2><p><img src="https://mdn.mozillademos.org/files/8633/promises.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Promise </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker常用命令</title>
      <link href="/Blog/2020/01/05/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/Blog/2020/01/05/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>简单记录一下初学的内容</p><a id="more"></a><h3 id="启动容器："><a href="#启动容器：" class="headerlink" title="启动容器："></a>启动容器：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run IMAGE [COMMAND] [ARG...]</span><br></pre></td></tr></table></figure><ul><li>docker run ubuntu echo ‘hello world’</li></ul><h3 id="启动交互式容器："><a href="#启动交互式容器：" class="headerlink" title="启动交互式容器："></a>启动交互式容器：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -i -t IMAGE /bin/bash</span><br></pre></td></tr></table></figure><ul><li>-i –interactive=true | false 默认 false</li><li>-t –tty=true | false 默认 false</li></ul><h3 id="查看容器："><a href="#查看容器：" class="headerlink" title="查看容器："></a>查看容器：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker ps [-a] [-l]</span><br><span class="line">$ docker inspect [容器名字，容器id]</span><br></pre></td></tr></table></figure><h3 id="重新启动停止的容器："><a href="#重新启动停止的容器：" class="headerlink" title="重新启动停止的容器："></a>重新启动停止的容器：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker start [-i] 容器名</span><br></pre></td></tr></table></figure><h3 id="进入容器【进入容器命令行】"><a href="#进入容器【进入容器命令行】" class="headerlink" title="进入容器【进入容器命令行】"></a>进入容器【进入容器命令行】</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker <span class="built_in">exec</span> -it [容器名，容器id] bash</span><br></pre></td></tr></table></figure><h3 id="删除停止的容器："><a href="#删除停止的容器：" class="headerlink" title="删除停止的容器："></a>删除停止的容器：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker rm 容器id</span><br></pre></td></tr></table></figure><h3 id="守护式容器"><a href="#守护式容器" class="headerlink" title="守护式容器"></a>守护式容器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d 镜像名 [COMMAND] [ARG...]</span><br></pre></td></tr></table></figure><hr><h3 id="运行docker"><a href="#运行docker" class="headerlink" title="运行docker"></a>运行docker</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -di --name=mynginx -p 8002:80 nginx</span><br></pre></td></tr></table></figure><ul><li>映射本地的8002端口</li></ul><h3 id="进入docker容器命令行"><a href="#进入docker容器命令行" class="headerlink" title="进入docker容器命令行"></a>进入docker容器命令行</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker <span class="built_in">exec</span> -it 镜像名 /bin/bash</span><br></pre></td></tr></table></figure><h3 id="部署静态页面到docker"><a href="#部署静态页面到docker" class="headerlink" title="部署静态页面到docker"></a>部署静态页面到docker</h3><ul><li>当前系统bash在vue项目的dist目录下</li><li>拷贝到名为mynginx的docker的默认html目录下<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker cp ./ mynginx:/usr/share/nginx/html</span><br></pre></td></tr></table></figure></li></ul><h2 id="迁移与备份"><a href="#迁移与备份" class="headerlink" title="迁移与备份"></a>迁移与备份</h2><ol><li>将容器保存为镜像 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker commit mynginx mynginx_i</span><br></pre></td></tr></table></figure></li><li>根据镜像生成运行新容器<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -id --name=mynginx2 -p 81:80 mynginx_i</span><br></pre></td></tr></table></figure></li><li>镜像导出为一个文件<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker save -o mynginx.tar mynginx_i</span><br></pre></td></tr></table></figure></li><li>文件恢复成镜像<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker load -i mynginx.tar</span><br></pre></td></tr></table></figure></li></ol><h3 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h3><p>需要先删除此镜像生成的容器</p><ol><li>停止容器</li><li>删除容器</li><li>删除镜像<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker stop 容器名</span><br><span class="line">$ docker rm 容器名</span><br><span class="line">$ docker rmi 镜像名</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker ps -a //查看所有容器</span><br><span class="line">$ docker images //查看所有镜像</span><br></pre></td></tr></table></figure></li></ol><hr><h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><p>相当于一个构建自定义镜像的脚本</p><blockquote><p><a href="https://docs.docker.com/engine/reference/builder/" target="_blank" rel="noopener">dockerfile官方文档说明 </a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>axios拦截器实现token认证</title>
      <link href="/Blog/2019/12/20/axios%E6%8B%A6%E6%88%AA%E5%99%A8%E5%AE%9E%E7%8E%B0token%E8%AE%A4%E8%AF%81/"/>
      <url>/Blog/2019/12/20/axios%E6%8B%A6%E6%88%AA%E5%99%A8%E5%AE%9E%E7%8E%B0token%E8%AE%A4%E8%AF%81/</url>
      
        <content type="html"><![CDATA[<blockquote><p>作者：mnn<br>链接：<a href="https://juejin.im/post/5bab739af265da0aa3593177" target="_blank" rel="noopener">https://juejin.im/post/5bab739af265da0aa3593177</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
          <category> Vue.js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> axios </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用http-server测试vue项目</title>
      <link href="/Blog/2019/12/19/%E4%BD%BF%E7%94%A8http-server%E6%B5%8B%E8%AF%95vue%E9%A1%B9%E7%9B%AE/"/>
      <url>/Blog/2019/12/19/%E4%BD%BF%E7%94%A8http-server%E6%B5%8B%E8%AF%95vue%E9%A1%B9%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="使用http-server测试vue打包的项目"><a href="#使用http-server测试vue打包的项目" class="headerlink" title="使用http-server测试vue打包的项目"></a>使用<code>http-server</code>测试vue打包的项目</h1><p>vue-cli build 打包后的项目，除了部署后预览外，也可以使用<code>http-server</code>快速预览。以下是详细说明：</p><a id="more"></a><blockquote><p><a href="https://github.com/http-party/http-server#readme" target="_blank" rel="noopener">项目 github 地址</a></p></blockquote><h1 id="http-server-a-command-line-http-server"><a href="#http-server-a-command-line-http-server" class="headerlink" title="http-server: a command-line http server"></a>http-server: a command-line http server</h1><p><code>http-server</code> is a simple, zero-configuration command-line http server.  It is powerful enough for production usage, but it’s simple and hackable enough to be used for testing, local development, and learning.</p><p><img src="https://github.com/nodeapps/http-server/raw/master/screenshots/public.png" alt=""></p><h1 id="Installing-globally"><a href="#Installing-globally" class="headerlink" title="Installing globally:"></a>Installing globally:</h1><p>Installation via <code>npm</code>:</p><pre><code>npm install http-server -g</code></pre><p>This will install <code>http-server</code> globally so that it may be run from the command line.</p><h2 id="Running-on-demand"><a href="#Running-on-demand" class="headerlink" title="Running on-demand:"></a>Running on-demand:</h2><p>Using <code>npx</code> you can run the script without installing it first:</p><pre><code>npx http-server [path] [options]</code></pre><h2 id="Usage"><a href="#Usage" class="headerlink" title="Usage:"></a>Usage:</h2><pre><code>http-server [path] [options]</code></pre><p><code>[path]</code> defaults to <code>./public</code> if the folder exists, and <code>./</code> otherwise.</p><p><em>Now you can visit <a href="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a> to view your server</em></p><p><strong>Note:</strong> Caching is on by default. Add <code>-c-1</code> as an option to disable caching.</p><h2 id="Available-Options"><a href="#Available-Options" class="headerlink" title="Available Options:"></a>Available Options:</h2><p><code>-p</code> or <code>--port</code> Port to use (defaults to 8080)</p><p><code>-a</code> Address to use (defaults to 0.0.0.0)</p><p><code>-d</code> Show directory listings (defaults to <code>true</code>)</p><p><code>-i</code> Display autoIndex (defaults to <code>true</code>)</p><p><code>-g</code> or <code>--gzip</code> When enabled (defaults to <code>false</code>) it will serve <code>./public/some-file.js.gz</code> in place of <code>./public/some-file.js</code> when a gzipped version of the file exists and the request accepts gzip encoding. If brotli is also enabled, it will try to serve brotli first.</p><p><code>-b</code> or <code>--brotli</code> When enabled (defaults to <code>false</code>) it will serve <code>./public/some-file.js.br</code> in place of <code>./public/some-file.js</code> when a brotli compressed version of the file exists and the request accepts <code>br</code> encoding. If gzip is also enabled, it will try to serve brotli first.</p><p><code>-e</code> or <code>--ext</code> Default file extension if none supplied (defaults to <code>html</code>)</p><p><code>-s</code> or <code>--silent</code> Suppress log messages from output</p><p><code>--cors</code> Enable CORS via the <code>Access-Control-Allow-Origin</code> header</p><p><code>-o [path]</code> Open browser window after starting the server. Optionally provide a URL path to open. e.g.: -o /other/dir/</p><p><code>-c</code> Set cache time (in seconds) for cache-control max-age header, e.g. <code>-c10</code> for 10 seconds (defaults to <code>3600</code>). To disable caching, use <code>-c-1</code>.</p><p><code>-U</code> or <code>--utc</code> Use UTC time format in log messages.</p><p><code>--log-ip</code> Enable logging of the client’s IP address (default: <code>false</code>).</p><p><code>-P</code> or <code>--proxy</code> Proxies all requests which can’t be resolved locally to the given url. e.g.: -P <a href="http://someurl.com" target="_blank" rel="noopener">http://someurl.com</a></p><p><code>--username</code> Username for basic authentication [none]</p><p><code>--password</code> Password for basic authentication [none]</p><p><code>-S</code> or <code>--ssl</code> Enable https.</p><p><code>-C</code> or <code>--cert</code> Path to ssl cert file (default: <code>cert.pem</code>).</p><p><code>-K</code> or <code>--key</code> Path to ssl key file (default: <code>key.pem</code>).</p><p><code>-r</code> or <code>--robots</code> Provide a /robots.txt (whose content defaults to <code>User-agent: *\nDisallow: /</code>)</p><p><code>--no-dotfiles</code> Do not show dotfiles</p><p><code>-h</code> or <code>--help</code> Print this list and exit.</p><p><code>-v</code> or <code>--version</code> Print the version and exit.</p><h2 id="Magic-Files"><a href="#Magic-Files" class="headerlink" title="Magic Files"></a>Magic Files</h2><ul><li><code>index.html</code> will be served as the default file to any directory requests.</li><li><code>404.html</code> will be served if a file is not found. This can be used for Single-Page App (SPA) hosting to serve the entry page.</li></ul><h2 id="Catch-all-redirect"><a href="#Catch-all-redirect" class="headerlink" title="Catch-all redirect"></a>Catch-all redirect</h2><p>To implement a catch-all redirect, use the index page itself as the proxy with:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http-server --proxy http:&#x2F;&#x2F;localhost:8080?</span><br></pre></td></tr></table></figure><p>Note the <code>?</code> at the end of the proxy URL. Thanks to <a href="https://github.com/houston3" target="_blank" rel="noopener">@houston3</a> for this clever hack!</p><h2 id="TLS-SSL"><a href="#TLS-SSL" class="headerlink" title="TLS/SSL"></a>TLS/SSL</h2><p>First, you need to make sure that <a href="https://github.com/openssl/openssl" target="_blank" rel="noopener">openssl</a> is installed correctly, and you have <code>key.pem</code> and <code>cert.pem</code> files. You can generate them using this command:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl req -newkey rsa:2048 -new -nodes -x509 -days 3650 -keyout key.pem -out cert.pem</span><br></pre></td></tr></table></figure><p>You will be prompted with a few questions after entering the command. Use <code>127.0.0.1</code> as value for <code>Common name</code> if you want to be able to install the certificate in your OS’s root certificate store or browser so that it is trusted.</p><p>This generates a cert-key pair and it will be valid for 3650 days (about 10 years).</p><p>Then you need to run the server with <code>-S</code> for enabling SSL and <code>-C</code> for your certificate file.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http-server -S -C cert.pem</span><br></pre></td></tr></table></figure><p>This is what should be output if successful:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Starting up http-server, serving ./ through https</span><br><span class="line">Available on:</span><br><span class="line">  https:127.0.0.1:8080</span><br><span class="line">  https:192.168.1.101:8080</span><br><span class="line">  https:192.168.1.104:8080</span><br><span class="line">Hit CTRL-C to stop the server</span><br></pre></td></tr></table></figure><h1 id="Development"><a href="#Development" class="headerlink" title="Development"></a>Development</h1><p>Checkout this repository locally, then:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm i</span><br><span class="line">$ node bin/http-server</span><br></pre></td></tr></table></figure><p><em>Now you can visit <a href="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a> to view your server</em></p><p>You should see the turtle image in the screenshot above hosted at that URL. See<br>the <code>./public</code> folder for demo content.</p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
          <category> Vue.js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Coding </tag>
            
            <tag> Node.js </tag>
            
            <tag> Vue.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript之call()与apply()</title>
      <link href="/Blog/2019/12/09/JavaScript%E4%B9%8Bcall/"/>
      <url>/Blog/2019/12/09/JavaScript%E4%B9%8Bcall/</url>
      
        <content type="html"><![CDATA[<h2 id="Function-prototype-call"><a href="#Function-prototype-call" class="headerlink" title="Function.prototype.call()"></a>Function.prototype.call()</h2><p><code>call</code>方法使用一个指定的<code>this</code>值和单独给出的一个或多个参数来调用一个函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Product</span>(<span class="params">name, price</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.price = price;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Food</span>(<span class="params">name, price</span>) </span>&#123;</span><br><span class="line">  Product.call(<span class="keyword">this</span>, name, price);</span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">        错误写法： Product(name,price) 相当于 Product.call(null,name,price)，</span></span><br><span class="line"><span class="comment">        非严格模式下，null或者undefined会自动替换为指向全局对象，如果在浏览器下则是</span></span><br><span class="line"><span class="comment">        window ，所以相当于Product.call(window,name,price)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="keyword">this</span>.category = <span class="string">'food'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> Food(<span class="string">'cheese'</span>, <span class="number">5</span>));</span><br><span class="line"><span class="comment">// 结果: Food &#123;name: "cheese", price: 5, category: "food"&#125;</span></span><br></pre></td></tr></table></figure><blockquote><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call" target="_blank" rel="noopener">MDN 文档 call</a></p></blockquote><h2 id="Function-prototype-apply"><a href="#Function-prototype-apply" class="headerlink" title="Function.prototype.apply()"></a>Function.prototype.apply()</h2><p><code>apply()</code> 方法调用一个具有给定<code>this</code>值的函数，以及作为一个数组（或类似数组对象）提供的参数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">5</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> max = <span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, numbers);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(max);</span><br><span class="line"><span class="comment">// expected output: 7</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> min = <span class="built_in">Math</span>.min.apply(<span class="literal">null</span>, numbers);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(min);</span><br><span class="line"><span class="comment">// expected output: 2</span></span><br></pre></td></tr></table></figure><h3 id="备注：Math-max"><a href="#备注：Math-max" class="headerlink" title="备注：Math.max"></a>备注：Math.max</h3><p><code>max</code> 是 <code>Math</code> 的静态方法，所以直接使用：<code>Math.max()</code>,而不是创建的<code>Math</code>实例的方法(<code>Math</code>不是构造函数，通过<code>typeof(Math)</code>可以看到，<code>Math</code>是一个<code>Object</code>,没有<code>prototype</code>)。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><blockquote><p><b style="font-size:1.4em">Math.max(value1[,value2,value3,…])</b></p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.max(numbers)</span><br><span class="line"><span class="comment">//运行结果 NaN</span></span><br></pre></td></tr></table></figure><p>若不使用<code>apply()</code>，运行结果为NaN，原因是相当于只提供了一个参数（numbers数组），<code>max</code>方法给定的参数无法被转换为数字，则会返回<code>NaN</code>。</p><blockquote><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/apply" target="_blank" rel="noopener">MDN 文档 apply</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Coding </tag>
            
            <tag> JavaScript </tag>
            
            <tag> call </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从npm迁移yarn</title>
      <link href="/Blog/2019/12/04/%E4%BB%8Enpm%E8%BF%81%E7%A7%BByarn/"/>
      <url>/Blog/2019/12/04/%E4%BB%8Enpm%E8%BF%81%E7%A7%BByarn/</url>
      
        <content type="html"><![CDATA[<p>Yarn和npm使用相同的 <code>package.json</code> 格式，而且从 npm 迁移 Yarn 可以从npm安装依赖包。</p><p>只需执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn</span><br></pre></td></tr></table></figure><p>Yarn 将通过自己的解析算法来重新组织 <code>node_modules</code> 目录，这个算法和<a href="https://nodejs.org/api/modules.html#modules_all_together" target="_blank" rel="noopener">node.js 模块解析算法</a>是兼容的。</p><a id="more"></a><h2 id="CLI命令比较"><a href="#CLI命令比较" class="headerlink" title="CLI命令比较"></a>CLI命令比较</h2><table><thead><tr><th>npm(v5)</th><th>Yarn</th></tr></thead><tbody><tr><td>npm install</td><td>yarn install</td></tr><tr><td>不适用</td><td>yarn install –flat</td></tr><tr><td>不适用</td><td>yarn install –har</td></tr><tr><td>npm install –no-package-lock</td><td>yarn install –no-lockfile</td></tr><tr><td>(不适用)</td><td>yarn install –pure-lockfile</td></tr><tr><td>npm install [package]</td><td>yarn add [package]</td></tr><tr><td>npm install [package] –save-dev</td><td>yarn add [package] –dev</td></tr><tr><td>(不适用)</td><td>yarn add [package] –peer</td></tr><tr><td>npm install [package] –save-optional</td><td>yarn add [package] –optional</td></tr><tr><td>npm install [package] –save-exact</td><td>yarn add [package] –exact</td></tr><tr><td>(不适用)</td><td>yarn add [package] –tilde</td></tr><tr><td>npm install [package] –global</td><td>yarn global add [package]</td></tr><tr><td>npm update –global</td><td>yarn global upgrade</td></tr><tr><td>npm rebuild</td><td>yarn install –force</td></tr><tr><td>npm uninstall [package]</td><td>yarn remove [package]</td></tr><tr><td>npm cache clean</td><td>yarn cache clean [package]</td></tr><tr><td>rm -rf node_modules &amp;&amp; npm install</td><td>yarn upgrade</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
          <category> Vue.js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> yarn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES6优化vue项目代码</title>
      <link href="/Blog/2019/12/02/ES6%E4%BC%98%E5%8C%96vue%E9%A1%B9%E7%9B%AE%E4%BB%A3%E7%A0%81/"/>
      <url>/Blog/2019/12/02/ES6%E4%BC%98%E5%8C%96vue%E9%A1%B9%E7%9B%AE%E4%BB%A3%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h2 id="ES6简写"><a href="#ES6简写" class="headerlink" title="ES6简写"></a>ES6简写</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//没有简写</span></span><br><span class="line">&#123;</span><br><span class="line">    method: &#123;</span><br><span class="line">        getValue: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    computed: &#123;</span><br><span class="line">        halfValue: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    created: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用ES6简写</span></span><br><span class="line">&#123;</span><br><span class="line">    method: &#123;</span><br><span class="line">        getValue() &#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    computed: &#123;</span><br><span class="line">        halfValue() &#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    created() &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解构"><a href="#解构" class="headerlink" title="解构"></a>解构</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">    name: <span class="string">'Jake'</span>,</span><br><span class="line">    email: <span class="string">'jake@example.com'</span>,</span><br><span class="line">    phone: <span class="string">'123-231-3123'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//没有解构</span></span><br><span class="line"><span class="keyword">const</span> name = person.name</span><br><span class="line"><span class="keyword">const</span> email = person.email</span><br><span class="line"><span class="keyword">const</span> phone = person.phone</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用解构</span></span><br><span class="line"><span class="keyword">const</span> &#123;</span><br><span class="line">    name,</span><br><span class="line">    email,</span><br><span class="line">    phone</span><br><span class="line">&#125; = person</span><br></pre></td></tr></table></figure><h3 id="Vue中主要两个领域适合做解构：-从-this-中解构属性；从作用域插槽接收-prop。"><a href="#Vue中主要两个领域适合做解构：-从-this-中解构属性；从作用域插槽接收-prop。" class="headerlink" title="Vue中主要两个领域适合做解构： 从 this 中解构属性；从作用域插槽接收 prop。"></a>Vue中主要两个领域适合做解构： 从 this 中解构属性；从作用域插槽接收 prop。</h3><h3 id="从this解构"><a href="#从this解构" class="headerlink" title="从this解构"></a>从this解构</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">data() &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            endpoint: <span class="string">'example.com/api'</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        postForm() &#123;</span><br><span class="line">            submitForm() &#123;</span><br><span class="line">                <span class="comment">//没有解构</span></span><br><span class="line">                <span class="keyword">const</span> endpoint = <span class="keyword">this</span>.endpoint</span><br><span class="line">                <span class="keyword">const</span> postForm = <span class="keyword">this</span>.postForm</span><br><span class="line"></span><br><span class="line">                <span class="comment">//使用解构</span></span><br><span class="line">                <span class="keyword">const</span> &#123;</span><br><span class="line">                    endpoint,</span><br><span class="line">                    postForm</span><br><span class="line">                &#125; = <span class="keyword">this</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>解构方式可以不用this前缀就使用这些变量，也可以清楚知道函数依赖于哪些数据和方法。</p><h3 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 不使用解构 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">User</span> <span class="attr">v-slot</span>=<span class="string">"slotProps"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>Name: &#123;&#123; slotProps.name &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>Email: &#123;&#123; slotProps.email &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">User</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 使用解构 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">User</span> <span class="attr">v-slot</span>=<span class="string">"&#123;name,email&#125;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>Name: &#123;&#123;name&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>Email: &#123;&#123;email&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">User</span>&gt;</span></span><br></pre></td></tr></table></figure><p>相比“从 this 解构”的模式，解构插槽 prop 不仅让我们可以不用 slotProps 前缀就访问变量，还向我们展示了通过插槽接收了哪些属性。</p><h2 id="新数组方法"><a href="#新数组方法" class="headerlink" title="新数组方法"></a>新数组方法</h2><p>map、排序数组、过滤数组<br>在Vue中常用的数组方法 filter、map、forEach、includes  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//filter示例</span></span><br><span class="line">computed: &#123;</span><br><span class="line">    <span class="comment">//不使用数组方法</span></span><br><span class="line">    oldFilteredItems() &#123;</span><br><span class="line">        <span class="keyword">const</span> filtered = []</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">in</span> <span class="keyword">this</span>.items) &#123;</span><br><span class="line">            <span class="keyword">if</span> (item.value &gt; <span class="number">10</span>) &#123;</span><br><span class="line">                filtered.push(item)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> filtered</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//使用数组方法</span></span><br><span class="line">    filteredItems() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.items.filter(<span class="function">(<span class="params">item</span>) =&gt;</span> item.value &gt; <span class="number">10</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">data() &#123;</span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">scrolled: <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">mounted() &#123;</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'scroll'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.scrolled = <span class="literal">true</span></span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码并不工作。创建新函数的时候，this 的值会重新绑定为等于函数实例，而不是Vue实例。<br>以下是解决方案：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mounted() &#123;</span><br><span class="line"><span class="keyword">var</span> self = <span class="keyword">this</span></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'scroll'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">self.scrolled = <span class="literal">true</span></span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然解决了问题，但是代码里<code>var self = this</code> 绝对难看，所以使用箭头函数解决此类问题   </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mounted() &#123;</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'scroll'</span>, () =&gt; &#123;</span><br><span class="line"><span class="keyword">this</span>.scrolled = <span class="literal">true</span></span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>箭头函数和this的关系，参照另一篇文章<a href="/2019/11/25/ES6箭头函数/">ES6箭头函数</a>，使用箭头函数替换标准函数，不会重新绑定this。</p></blockquote><p>编写Vue应用的时候，注意此规则：<code>在Vue组件中this应始终引用Vue实例。用好箭头函数的话这个目标很容易实现，这样你的代码就更容易理解了。</code></p><blockquote><p><a href="https://www.infoq.cn/article/mf_x3oizVrSruwpTevH5" target="_blank" rel="noopener">中文原文链接</a><br><a href="https://blog.logrocket.com/cleaning-up-your-vue-js-code-with-es6/" target="_blank" rel="noopener">英文原文链接</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
          <category> Vue.js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES6 </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES6箭头函数</title>
      <link href="/Blog/2019/11/25/ES6%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/"/>
      <url>/Blog/2019/11/25/ES6%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>ES6允许使用“箭头”（ <code>=&gt;</code> ）定义函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="params">v</span> =&gt;</span> v;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><a id="more"></a><p>如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数的部分。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="params">()</span> =&gt;</span> <span class="number">5</span>;</span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sum = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> num1 + num2;</span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用 <code>return</code> 语句返回。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>箭头函数可以与变量解构结合使用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> full = (&#123;</span><br><span class="line">    first,</span><br><span class="line">    last</span><br><span class="line">&#125;) =&gt; first + <span class="string">' '</span> + last;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">full</span>(<span class="params">person</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> person.first + <span class="string">' '</span> + person.last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>箭头函数使得表达更加简洁。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isEven = <span class="function"><span class="params">n</span> =&gt;</span> n % <span class="number">2</span> === <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> square = <span class="function"><span class="params">n</span> =&gt;</span> n * n;</span><br></pre></td></tr></table></figure><p>箭头函数的一个用处是简化回调函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正常函数写法</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].map(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭头函数写法</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].map(<span class="function"><span class="params">x</span> =&gt;</span> x * x);</span><br></pre></td></tr></table></figure><p>另一个例子是</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正常函数写法</span></span><br><span class="line"><span class="keyword">var</span> result = values.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭头函数写法</span></span><br><span class="line"><span class="keyword">var</span> result = values.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br></pre></td></tr></table></figure><p>下面是 rest 参数与箭头函数结合的例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = <span class="function">(<span class="params">...nums</span>) =&gt;</span> nums;</span><br><span class="line"></span><br><span class="line">numbers(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"><span class="comment">// [1,2,3,4,5]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> headAndTail = <span class="function">(<span class="params">head, ...tail</span>) =&gt;</span> [head, tail];</span><br><span class="line"></span><br><span class="line">headAndTail(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"><span class="comment">// [1,[2,3,4,5]]</span></span><br></pre></td></tr></table></figure><hr><h2 id="使用注意点"><a href="#使用注意点" class="headerlink" title="使用注意点"></a>使用注意点</h2><p>箭头函数的几个使用注意点：</p><ul><li>函数体内的 <code>this</code> 对象，就是定义时所在的对象，而不是使用时所在的对象。</li><li>不可以当作构造函数，也就是说，不可以使用 <code>new</code> 命令，否则会抛出一个错误。</li><li>不可以使用 <code>argument</code> 对象，该对象在函数体内不存在。如果要用，可以用rest参数代替。</li><li>不可以使用 <code>yield</code> 命令，因为箭头函数不能用作 Generator 函数。</li></ul><p><code>this</code> 对象的指向是可变的，但是在箭头函数中，它是固定的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'id'</span>, <span class="keyword">this</span>.id);</span><br><span class="line">    &#125;, <span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> id = <span class="number">23</span>;</span><br><span class="line"></span><br><span class="line">foo.call(&#123;</span><br><span class="line">    id: <span class="number">42</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中， <code>setTimeout</code> 的参数是一个箭头函数，这个箭头函数的定义生效是在 <code>foo</code> 函数生成时，而它的真正执行要等到100毫秒之后。如果是普通函数，执行时 <code>this</code> 应该指向全局对象 <code>window</code> ，这时应该输出 <code>21</code> 。但是，箭头函数导致 <code>this</code> 总是指向函数定义生效时所在的对象，所以输出的是 <code>42</code> 。</p><p>箭头函数可以让 <code>setTimeout</code> 里面的 <code>this</code> ，绑定定义时所在的作用域，而不是指向运行时所在的作用域。下面是另一个例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Timer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.s1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.s2 = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//箭头函数</span></span><br><span class="line">    setInterval(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">this</span>.s1++, <span class="number">1000</span>);</span><br><span class="line">    <span class="comment">//普通函数</span></span><br><span class="line">    setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.s2++;</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> timer = <span class="keyword">new</span> Timer()</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'s1: '</span>, timer.s1), <span class="number">3100</span>);</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'s2: '</span>, timer.s2), <span class="number">3100</span>);</span><br></pre></td></tr></table></figure><p>上面的代码中，<code>Timer</code>函数内部设置了两个定时器，分别使用了箭头函数和普通函数。<br>前者的<code>this</code>绑定定义时所在的作用域（即<code>Timer</code>函数），后者的<code>this</code>指向运行时所在的作用域（即全局对象）。所以，3100毫秒之后，<code>timer.s1</code>被更新了3次，而<code>timer.s2</code>一次也没有更新。</p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES6 </tag>
            
            <tag> 箭头函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue生命周期</title>
      <link href="/Blog/2019/11/21/vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
      <url>/Blog/2019/11/21/vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
          <category> Vue.js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>uni-app导航栏开发指南</title>
      <link href="/Blog/2019/11/20/uni-app%E5%AF%BC%E8%88%AA%E6%A0%8F%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/"/>
      <url>/Blog/2019/11/20/uni-app%E5%AF%BC%E8%88%AA%E6%A0%8F%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<blockquote><p>将官方社区的文章照搬过来，一方面正好在熟悉这块内容，另一方面熟练自己的md语法。<br>原文链接<a href="https://ask.dcloud.net.cn/article/34921" target="_blank" rel="noopener">https://ask.dcloud.net.cn/article/34921</a></p></blockquote><a id="more"></a><p>uni-app 自带原生导航栏，在pages.json里配置。<br>原生导航的体验更好，渲染新页面时，原生导航栏的渲染无需等待新页面dom加载，可以在新页面进入动画开始时就渲染。  </p><p>原生导航还可以避免滚动条通顶，并方便的控制原生下拉刷新。<br>通过pages.json的配置，可以简单的、跨端的、高性能的开发业务。  </p><p>但原生导航栏的扩展能力有限。尤其是微信下，没有提供太多导航栏的配置。<br>在App下，pages.json里每个页面的app-plus下可以设置titleNView等更多参数，可以得到比微信小程序更丰富的扩展性。<br>另外，开发者也可以在必要时取消原生导航栏，使用view自行绘制导航栏。</p><h2 id="原生导航栏的通用配置"><a href="#原生导航栏的通用配置" class="headerlink" title="原生导航栏的通用配置"></a><strong>原生导航栏的通用配置</strong></h2><p>原生导航栏的配置，均在pages.json里，每个page下面的style配置中的navigationBar各个参数配置，即为通用配置，小程序、app、h5均生效。参考<a href="https://uniapp.dcloud.io/collocation/pages?id=style" target="_blank" rel="noopener">https://uniapp.dcloud.io/collocation/pages?id=style</a></p><h2 id="全局取消原生导航栏"><a href="#全局取消原生导航栏" class="headerlink" title="全局取消原生导航栏"></a><strong>全局取消原生导航栏</strong></h2><p>在pages.json的globalStyle里，有个navigationStyle设置，默认是default，即带有原生导航栏。也可以设置为custom。<br>在设为custom后，所有页面都没有原生导航。<br>但在微信小程序里，右上角始终都有一个胶囊按钮。<br>很多微信小游戏界面也没原生导航栏，但有胶囊按钮。<br>一般App里不会使用这个参数配置。建议个别页面单独设置不使用原生导航，具体如下。</p><h2 id="单独去除原生导航栏"><a href="#单独去除原生导航栏" class="headerlink" title="单独去除原生导航栏"></a><strong>单独去除原生导航栏</strong></h2><p>自微信客户端7.0.0起，App端HBuilderX2.0.3起，支持通过如下方法取消单独一个页面的原生导航。但小程序右上角胶囊按钮仍然去不掉。页面配置 navigationStyle 为 custom:   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;path&quot; : &quot;pages&#x2F;log.log&quot;,</span><br><span class="line">    &quot;style&quot; : &#123;</span><br><span class="line">        &quot;navigationStyle&quot;:&quot;custom&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
          <category> uni-app </category>
          
      </categories>
      
      
        <tags>
            
            <tag> uni-app </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo写作命令</title>
      <link href="/Blog/2019/11/20/hexo%E5%86%99%E4%BD%9C%E5%91%BD%E4%BB%A4/"/>
      <url>/Blog/2019/11/20/hexo%E5%86%99%E4%BD%9C%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="新建文章"><a href="#新建文章" class="headerlink" title="新建文章"></a><strong>新建文章</strong></h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure><p>layout : 默认为<code>post</code>，可以修改<code>_config.yml</code>中的<code>default_layout</code>参数来指定默认布局  </p><h1 id="布局（Layout）"><a href="#布局（Layout）" class="headerlink" title="布局（Layout）"></a><strong>布局（Layout）</strong></h1><p>Hexo 有三种默认布局：<code>post</code>、<code>page</code> 和 <code>draft</code>。在创建这三种不同类型的文件时，它们将会被保存到不同的路径；而您自定义的其他布局和 <code>post</code> 相同，都将存储到 <code>source/_posts</code> 文件夹中。  </p><table><thead><tr><th><strong>布局</strong></th><th><strong>路径</strong></th></tr></thead><tbody><tr><td><code>post</code></td><td><code>source/_posts</code></td></tr><tr><td><code>page</code></td><td><code>source</code></td></tr><tr><td><code>draft</code></td><td><code>source/_drafts</code></td></tr></tbody></table><blockquote><p>如果不希望文章被处理，可以将 Front-Matter 中的 <code>layout:</code> 设为 <code>false</code>。</p></blockquote><h1 id="预览"><a href="#预览" class="headerlink" title="预览"></a><strong>预览</strong></h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> 关于博客 </category>
          
          <category> hexo命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx+uwsgi+CentOS7部署Django</title>
      <link href="/Blog/2019/10/24/Nginx-uwsgi-CentOS7%E9%83%A8%E7%BD%B2Django/"/>
      <url>/Blog/2019/10/24/Nginx-uwsgi-CentOS7%E9%83%A8%E7%BD%B2Django/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
          <category> Django </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Django </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CAGED系统</title>
      <link href="/Blog/2019/10/24/CAGED%E7%B3%BB%E7%BB%9F/"/>
      <url>/Blog/2019/10/24/CAGED%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Guitar </category>
          
          <category> 乐理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 乐理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>七和弦</title>
      <link href="/Blog/2019/10/24/%E4%B8%83%E5%92%8C%E5%BC%A6/"/>
      <url>/Blog/2019/10/24/%E4%B8%83%E5%92%8C%E5%BC%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="七和弦的分类"><a href="#七和弦的分类" class="headerlink" title="七和弦的分类"></a>七和弦的分类</h1><h3 id="1-由4个音按照三度叠加构成，根音与最高音之间成七度音程"><a href="#1-由4个音按照三度叠加构成，根音与最高音之间成七度音程" class="headerlink" title="1. 由4个音按照三度叠加构成，根音与最高音之间成七度音程"></a>1. 由4个音按照三度叠加构成，根音与最高音之间成七度音程</h3><p><img src="https://cdn.jsdelivr.net/gh/CoryLiu/Img-repo@master/static_files/lyb/img/avatar20191025142352.png" alt=""></p><h3 id="2-七和弦的分类：在C大调顺阶和弦中，所有的三和弦都可以变化成七和弦"><a href="#2-七和弦的分类：在C大调顺阶和弦中，所有的三和弦都可以变化成七和弦" class="headerlink" title="2. 七和弦的分类：在C大调顺阶和弦中，所有的三和弦都可以变化成七和弦"></a>2. 七和弦的分类：在C大调顺阶和弦中，所有的三和弦都可以变化成七和弦</h3><p><img src="https://cdn.jsdelivr.net/gh/CoryLiu/Img-repo@master/static_files/lyb/img/avatar20191025142546.png" alt=""></p><ol start="3"><li>常用七和弦的组成音  <br>Maj7：1-3-5-7  (大七和弦)  Dom7：1-3-5-b7  (属七和弦)  min7：1-b3-5-b7  (小七和弦)</li></ol><a id="more"></a><hr><h1 id="几乎所有七和弦指法-不要背，需学会自己根据音程推导"><a href="#几乎所有七和弦指法-不要背，需学会自己根据音程推导" class="headerlink" title="几乎所有七和弦指法(不要背，需学会自己根据音程推导)"></a>几乎所有七和弦指法(不要背，需学会自己根据音程推导)</h1><h3 id="Seventh（属7）"><a href="#Seventh（属7）" class="headerlink" title="Seventh（属7）"></a>Seventh（属7）</h3><p><img src="https://cdn.jsdelivr.net/gh/CoryLiu/Img-repo@master/static_files/lyb/img/avatar20191025143705.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/CoryLiu/Img-repo@master/static_files/lyb/img/avatar20191025143854.png" alt=""></p><h3 id="Diminished-Seventh（减7）"><a href="#Diminished-Seventh（减7）" class="headerlink" title="Diminished Seventh（减7）"></a>Diminished Seventh（减7）</h3><p><img src="https://cdn.jsdelivr.net/gh/CoryLiu/Img-repo@master/static_files/lyb/img/avatar20191025144052.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/CoryLiu/Img-repo@master/static_files/lyb/img/avatar20191025144115.png" alt=""></p><h3 id="Seventh-Suspended-Fourth（7挂4）"><a href="#Seventh-Suspended-Fourth（7挂4）" class="headerlink" title="Seventh, Suspended Fourth（7挂4）"></a>Seventh, Suspended Fourth（7挂4）</h3><p><img src="https://cdn.jsdelivr.net/gh/CoryLiu/Img-repo@master/static_files/lyb/img/avatar20191025144203.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/CoryLiu/Img-repo@master/static_files/lyb/img/avatar20191025144215.png" alt=""></p><h3 id="Major-Seventh（大7）"><a href="#Major-Seventh（大7）" class="headerlink" title="Major Seventh（大7）"></a>Major Seventh（大7）</h3><p><img src="https://cdn.jsdelivr.net/gh/CoryLiu/Img-repo@master/static_files/lyb/img/avatar20191025144244.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/CoryLiu/Img-repo@master/static_files/lyb/img/avatar20191025144257.png" alt=""></p><h3 id="Minor-Seventh（小7）"><a href="#Minor-Seventh（小7）" class="headerlink" title="Minor Seventh（小7）"></a>Minor Seventh（小7）</h3><p><img src="https://cdn.jsdelivr.net/gh/CoryLiu/Img-repo@master/static_files/lyb/img/avatar20191025144331.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/CoryLiu/Img-repo@master/static_files/lyb/img/avatar20191025144342.png" alt=""></p><h3 id="Minor，Major-Seventh（小大7）"><a href="#Minor，Major-Seventh（小大7）" class="headerlink" title="Minor，Major Seventh（小大7）"></a>Minor，Major Seventh（小大7）</h3><p><img src="https://cdn.jsdelivr.net/gh/CoryLiu/Img-repo@master/static_files/lyb/img/avatar20191025144433.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/CoryLiu/Img-repo@master/static_files/lyb/img/avatar20191025144448.png" alt=""></p><h3 id="Major-Seventh，Flat-Fifth（大7降5）"><a href="#Major-Seventh，Flat-Fifth（大7降5）" class="headerlink" title="Major Seventh，Flat Fifth（大7降5）"></a>Major Seventh，Flat Fifth（大7降5）</h3><p><img src="https://cdn.jsdelivr.net/gh/CoryLiu/Img-repo@master/static_files/lyb/img/avatar20191025144638.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/CoryLiu/Img-repo@master/static_files/lyb/img/avatar20191025144652.png" alt=""></p><h3 id="Minor-Seeventh，Flat-Fifth（小7降5）"><a href="#Minor-Seeventh，Flat-Fifth（小7降5）" class="headerlink" title="Minor Seeventh，Flat Fifth（小7降5）"></a>Minor Seeventh，Flat Fifth（小7降5）</h3><p><img src="https://cdn.jsdelivr.net/gh/CoryLiu/Img-repo@master/static_files/lyb/img/avatar20191025144740.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/CoryLiu/Img-repo@master/static_files/lyb/img/avatar20191025144752.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Guitar </category>
          
          <category> 乐理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 乐理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/Blog/2019/10/20/hello-world/"/>
      <url>/Blog/2019/10/20/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于Vue中computed和watch使用场景的思考</title>
      <link href="/Blog/2019/10/16/%E5%85%B3%E4%BA%8EVue%E4%B8%ADcomputed%E5%92%8Cwatch%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E7%9A%84%E6%80%9D%E8%80%83/"/>
      <url>/Blog/2019/10/16/%E5%85%B3%E4%BA%8EVue%E4%B8%ADcomputed%E5%92%8Cwatch%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E7%9A%84%E6%80%9D%E8%80%83/</url>
      
        <content type="html"><![CDATA[<h1 id="为何需要计算属性（computed）"><a href="#为何需要计算属性（computed）" class="headerlink" title="为何需要计算属性（computed）"></a>为何需要计算属性（computed）</h1><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example"</span>&gt;</span></span><br><span class="line">  &#123;&#123; message.split('').reverse().join('') &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>需要对data进行一些简单的计算与操作的时候，如上代码，直接在模板中放入逻辑。假如这个操作比较复杂，则对于页面后续的维护不易。假如页面中多个地方都需要进行相同的计算，那岂不是都需要复制一遍，当计算规则改变时，岂不是每个地方都需要进行修改。那么这种方式明显是不合适的。<br>所以vue提供了<code>计算属性</code>这一特性：</p><h2 id="基础例子"><a href="#基础例子" class="headerlink" title="基础例子"></a>基础例子</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Original message: "&#123;&#123; message &#125;&#125;"<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Computed reversed message: "&#123;&#123; reversedMessage &#125;&#125;"<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#example'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    message: <span class="string">'Hello'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    <span class="comment">// 计算属性的 getter</span></span><br><span class="line">    reversedMessage: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// `this` 指向 vm 实例</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.message.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>vm.reversedMessage依赖于vm.message，所以当vm.message发生改变的时候，所有依赖vm.reverseMessage的绑定也会更新。</p><h2 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h2><p>与直接在模板中使用method的方式比较，使用computed只有在依赖的数据发生改变时才会进行计算，也就是它是有缓存的，使用method，则每次访问reverseMessage都将进行一次新的计算。这无疑对性能是不好的。</p><h1 id="侦听属性（watch）"><a href="#侦听属性（watch）" class="headerlink" title="侦听属性（watch）"></a>侦听属性（watch）</h1><p>vue官方的说法是，在需要数据变化的时候执行异步或开销较大的操作时(在computed中无法做到异步操作，异步函数执行之后，回调函数中返回值并不会触发dom的重新渲染)，使用watch</p><p>异步ajax请求的发起，可以使用 <a href="https://lodash.com/" target="_blank" rel="noopener">Lodash</a> 模块的 <a href="https://lodash.com/docs#debounce" target="_blank" rel="noopener">_.debounce</a> 进行请求发起的间隔，防止修改数据过于频繁，导致ajax请求无限发送，影响性能。</p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
          <category> Vue.js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue.js </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
