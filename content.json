{"meta":{"title":"阿b的Blog","subtitle":"因为夹娃娃很疗愈啊","description":null,"author":"Liu","url":"https://coryliu.github.io/Blog","root":"/Blog/"},"pages":[{"title":"404 Not Found","date":"2020-03-31T02:34:42.020Z","updated":"2020-03-31T02:34:42.020Z","comments":true,"path":"404.html","permalink":"https://coryliu.github.io/Blog/404.html","excerpt":"","text":"404 Not Found **很抱歉，您访问的页面不存在** 可能是输入地址有误或该地址已被删除"},{"title":"关于","date":"2020-03-31T02:34:42.020Z","updated":"2020-03-31T02:34:42.020Z","comments":true,"path":"about/index.html","permalink":"https://coryliu.github.io/Blog/about/index.html","excerpt":"","text":"关于主题本站主题是：Material X One More Thing懒加载占位图如果喜欢请拿去：图片链接 我的沙雕航拍"},{"title":"","date":"2020-03-31T02:34:42.020Z","updated":"2020-03-31T02:34:42.020Z","comments":true,"path":"friends/index.html","permalink":"https://coryliu.github.io/Blog/friends/index.html","excerpt":"","text":"这个人很孤独，木得盆友 名称： abin’s blog头像： https://cdn.jsdelivr.net/gh/CoryLiu/Img-repo@master/static_files/lyb/img/avatar头像.jpg网址： https://coryliu.github.io/Blog/标签： hexo"},{"title":"","date":"2020-03-31T02:34:42.020Z","updated":"2020-03-31T02:34:42.020Z","comments":true,"path":"projects/index.html","permalink":"https://coryliu.github.io/Blog/projects/index.html","excerpt":"","text":""},{"title":"所有分类","date":"2020-03-31T02:34:42.020Z","updated":"2020-03-31T02:34:42.020Z","comments":true,"path":"blog/categories/index.html","permalink":"https://coryliu.github.io/Blog/blog/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2020-03-31T02:34:42.020Z","updated":"2020-03-31T02:34:42.020Z","comments":true,"path":"blog/tags/index.html","permalink":"https://coryliu.github.io/Blog/blog/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"express笔记","slug":"express笔记","date":"2020-03-31T10:22:12.000Z","updated":"2020-03-31T02:34:42.020Z","comments":true,"path":"2020/03/31/express笔记/","link":"","permalink":"https://coryliu.github.io/Blog/2020/03/31/express%E7%AC%94%E8%AE%B0/","excerpt":"","text":"安装1npm install express --save Express应用程序生成器express-generator 快速创建一个应用的骨架 1npm install -g express-generator express命令行参数1234567891011121314151617express -h Usage: express [options] [dir] Options: -h, --help 输出使用方法 --version 输出版本号 -e, --ejs 添加对 ejs 模板引擎的支持 --hbs 添加对 handlebars 模板引擎的支持 --pug 添加对 pug 模板引擎的支持 -H, --hogan 添加对 hogan.js 模板引擎的支持 --no-view 创建不带视图引擎的项目 -v, --view &lt;engine&gt; 添加对视图引擎（view） &lt;engine&gt; 的支持 (ejs|hbs|hjs|jade|pug|twig|vash) （默认是 jade 模板引擎） -c, --css &lt;engine&gt; 添加样式表引擎 &lt;engine&gt; 的支持 (less|stylus|compass|sass) （默认是普通的 css 文件） --git 添加 .gitignore -f, --force 强制在非空目录下创建 例：创建了一个名称为 myapp 的 Express 应用 1express --view=pug myapp 1cd myapp 1npm install 启动appMacOS or Linux： 1DEBUG=myapp:* npm start Windows 12set DEBUG=myapp:*npm start 生成示例的文件结构12345678910111213141516171819.├── app.js├── bin│ └── www├── package.json├── public│ ├── images│ ├── javascripts│ └── stylesheets│ └── style.css├── routes│ ├── index.js│ └── users.js└── views ├── error.pug ├── index.pug └── layout.pug7 directories, 9 files","categories":[{"name":"Coding","slug":"Coding","permalink":"https://coryliu.github.io/Blog/blog/categories/Coding/"},{"name":"Express","slug":"Coding/Express","permalink":"https://coryliu.github.io/Blog/blog/categories/Coding/Express/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coryliu.github.io/Blog/blog/tags/JavaScript/"},{"name":"Node.js","slug":"Node-js","permalink":"https://coryliu.github.io/Blog/blog/tags/Node-js/"},{"name":"Express","slug":"Express","permalink":"https://coryliu.github.io/Blog/blog/tags/Express/"}]},{"title":"持续集成服务Travis CI","slug":"持续集成服务Travis-CI","date":"2020-03-23T20:50:00.000Z","updated":"2020-03-31T02:34:42.020Z","comments":true,"path":"2020/03/23/持续集成服务Travis-CI/","link":"","permalink":"https://coryliu.github.io/Blog/2020/03/23/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E6%9C%8D%E5%8A%A1Travis-CI/","excerpt":"","text":"什么是Travis为了提高软件开发效率而诞生的，构建和测试的自动化工具。 引用","categories":[{"name":"Coding","slug":"Coding","permalink":"https://coryliu.github.io/Blog/blog/categories/Coding/"},{"name":"Travis","slug":"Coding/Travis","permalink":"https://coryliu.github.io/Blog/blog/categories/Coding/Travis/"}],"tags":[{"name":"Github","slug":"Github","permalink":"https://coryliu.github.io/Blog/blog/tags/Github/"},{"name":"Travis","slug":"Travis","permalink":"https://coryliu.github.io/Blog/blog/tags/Travis/"}]},{"title":"js基础知识回忆与巩固","slug":"js基础知识回忆与巩固","date":"2020-03-12T20:59:11.000Z","updated":"2020-03-31T02:34:42.020Z","comments":true,"path":"2020/03/12/js基础知识回忆与巩固/","link":"","permalink":"https://coryliu.github.io/Blog/2020/03/12/js%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%9B%9E%E5%BF%86%E4%B8%8E%E5%B7%A9%E5%9B%BA/","excerpt":"1：Vue nextTick特性 以下内容来自 vue2.x 官方文档 Vue.nextTrick([callback,context]) 参数： {Function} [callback] {Object} [context] 用法：在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更行后的DOM","text":"1：Vue nextTick特性 以下内容来自 vue2.x 官方文档 Vue.nextTrick([callback,context]) 参数： {Function} [callback] {Object} [context] 用法：在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更行后的DOM 1234567891011121314151617181920212223242526272829 export default &#123; data () &#123; return &#123; msg: 'hello' &#125; &#125;, created () &#123; this.initData() &#125;, methods: &#123; initData () &#123; console.log('initData') setTimeout(() =&gt; &#123; this.msg = '修改msg的值' // DOM 还没有更新 console.log(this) //使用箭头函数，this指向vue组件实例 this.$nextTick(()=&gt; &#123; //DOM 更新了 console.log(`触发了nextTrick的回调函数,msg的值已经修改,当前msg的值： $&#123;this.msg&#125;`) &#125;) // Promise写法 this.$nextTick() .then(function()&#123; //DOM更新了 &#125;) &#125;, 3000) &#125; &#125;&#125; 需要使用nextTick的场景当设置 vm.someData = ‘new value’ 时，组件不会立即重更新渲染。当你刷新队列时，组件会在下一个事件循环“tick”中更新。当需要用更新后的DOM来做点什么的时候，比如重新加载JQuery插件… 为了在数据变化之后等待 Vue 完成更新DOM，可以在数据变化之后立即使用 Vue.nextTick(callback) 。这样回调函数将在DOM更新完成后被调用。 更多内容： 异步更新队列继续了解Vue响应式原理检测变化的注意事项Vue无法检测到对象属性的添加或删除。因为Vue在初始化实例时对属性执行 getter/setter 转化，所以属性必须在 data 对象上存在才能让 Vue 将它转换为响应式。 12345678910var vm = new Vue(&#123; data:&#123; a:1 &#125;&#125;)// `vm.a` 是响应式的vm.b = 2// `vm.b` 是非响应式的 对于已经创建的实例，Vue 不允许动态添加根级别的响应式属性。可以使用 Vue.set(object, propertyName, value) 方法向嵌套对象添加响应式属性。 1234567891011121314151617181920212223var vm = new Vue(&#123; el: '#app', data: &#123; msg: 'hello', obj: &#123; a: 1, b: 3 &#125; &#125;, beforeCreate: function () &#123; console.log(this) &#125;, created: function () &#123; this.a = 2 &#125;, methods: &#123; change() &#123; this.$set(this.obj, 'c', 444) //DOM将会更新 //this.obj.c = 444 //不会更新DOM this.$nextTick() &#125; &#125; &#125;) 2：前端常见的内存泄漏问题三种类型的常见 JavaScript 内存泄漏 意外的全局变量未定义的变量会在全局对象创建一个新变量 123function foo(arg)&#123; bar = \"this is a hidden global variable\"&#125; 函数 foo 内部忘记使用 var ，意外创建了一个全局变量。此例泄漏了一个简单的字符串，无伤大雅，但是有更糟的情况。另一种意外的全局变量可能由 this 创建： 123456function foo() &#123; this.variable = \"potential accidental global\"; &#125; // Foo 调用自己，this 指向了全局对象（window） // 而不是 undefined foo(); 在 JavaScript 文件头部加上 ‘use strict’，可以避免此类错误发生。启用严格模式解析 JavaScript ，避免意外的全局变量。 尽管我们讨论了一些意外的全局变量，但是仍有一些明确的全局变量产生的垃圾。它们被定义为不可回收（除非定义为空或重新分配）。尤其当全局变量用于临时存储和处理大量信息时，需要多加小心。如果必须使用全局变量存储大量数据时，确保用完以后把它设置为 null 或者重新定义。与全局变量相关的增加内存消耗的一个主因是缓存。缓存数据是为了重用，缓存必须有一个大小上限才有用。高内存消耗导致缓存突破上限，因为缓存内容无法被回收。 被遗忘的计时器或回调函数 12345678var someResource = getData(); setInterval(function() &#123; var node = document.getElementById('Node'); if(node) &#123; // 处理 node 和 someResource node.innerHTML = JSON.stringify(someResource)); &#125; &#125;, 1000); 脱离 DOM 的引用有时，保存 DOM 节点内部数据结构很有用。假如你想快速更新表格的几行内容，把每一行 DOM 存成字典（JSON 键值对）或者数组很有意义。此时，同样的 DOM 元素存在两个引用：一个在 DOM 树中，另一个在字典中。将来你决定删除这些行时，需要把两个引用都清除。 1234567891011121314151617var elements = &#123; button: document.getElementById('button'), image: document.getElementById('image'), text: document.getElementById('text') &#125;; function doStuff() &#123; image.src = 'http://some.url/image'; button.click(); console.log(text.innerHTML); // 更多逻辑 &#125; function removeButton() &#123; // 按钮是 body 的后代元素 document.body.removeChild(document.getElementById('button')); // 此时，仍旧存在一个全局的 #button 的引用 // elements 字典。button 元素仍旧在内存中，不能被 GC 回收。 &#125; 此外还要考虑 DOM 树内部或子节点的引用问题。假如你的 JavaScript 代码中保存了表格某一个 &lt;td&gt; 的引用。将来决定删除整个表格的时候，直觉认为 GC 会回收除了已保存的 &lt;td&gt; 以外的其它节点。实际情况并非如此：此 &lt;td&gt; 是表格的子节点，子元素与父元素是引用关系。由于代码保留了 &lt;td&gt; 的引用，导致整个表格仍待在内存中。保存 DOM 元素引用的时候，要小心谨慎。 闭包闭包是 JavaScript 开发的一个关键方面：匿名函数可以访问父级作用域的变量 123456789101112131415var theThing = null;var replaceThing = function () &#123; var originalThing = theThing; var unused = function () &#123; if (originalThing) console.log(\"hi\"); &#125;; theThing = &#123; longStr: new Array(1000000).join('*'), someMethod: function () &#123; console.log(someMessage); &#125; &#125;;&#125;;setInterval(replaceThing, 1000); 代码片段做了一件事情：每次调用 replaceThing ，theThing 得到一个包含一个大数组和一个新闭包（someMethod）的新对象。同时，变量 unused 是一个引用 originalThing 的闭包（先前的 replaceThing 又调用了 theThing ）。思绪混乱了吗？最重要的事情是，闭包的作用域一旦创建，它们有同样的父级作用域，作用域是共享的。someMethod 可以通过 theThing 使用，someMethod 与 unused 分享闭包作用域，尽管 unused 从未使用，它引用的 originalThing 迫使它保留在内存中（防止被回收）。当这段代码反复运行，就会看到内存占用不断上升，垃圾回收器（GC）并无法降低内存占用。本质上，闭包的链表已经创建，每一个闭包作用域携带一个指向大数组的间接的引用，造成严重的内存泄漏。 解决方法：在 replaceThing 的最后添加 originalThing = null 。 3：vue, angular, react框架各自的优缺点 React：由Fackbook创建的JavaScript UI框架。React推广了VirtualDOM并创造了新语法——JSX，JSX允许开发者在JavaScript中书写HTML。 Vue：Vue致力解决的问题与React一致，解决方案不同。Vue使用模板系统而不是JSX，因为模板用的是普通的HTML，所以通过Vue对现有系统的升级更加容易，不需要整体重构。 相似之处React与Vue存在很多相似之处，例如他们都是JavaScript的UI框架，专注于创造前端的富应用。不同于早期的JavaScript框架“功能齐全”，Reat与Vue只有框架的骨架，其他的功能如路由、状态管理等是框架分离的组件。 组件化React与Vue都鼓励组件化应用。这本质上说，是建议你将你的应用分拆成一个个功能明确的模块，每个模块之间可以通过合适的方式互相联系。 不同React和Vue在实现VirtualDOM转换为真实DOM的实现方式不同。Vue在渲染过程中，会跟踪每一个组件的依赖关系，不需要重新渲染整个组件树。React，当应用的状态被修改时，全部子组件都会重新渲染。当然，这可以通过shouldComponentUpdate这个生命周期方法来进行控制，但Vue将此视为默认的优化。 构建工具React可以使用Create React App (CRA)Vue对应的则是vue-cli 配套框架 Vue与React最后一个相似但略有不同之处是它们配套框架的处理方法。相同之处在于，两个框架都专注于UI层，其他的功能如路由、状态管理等都交由同伴框架进行处理。 而不同之处是在于它们如何关联它们各自的配套框架。Vue的核心团队维护着vue-router和vuex，它们都是作为官方推荐的存在。而React的react-router和react-redux则是由社区成员维护，它们都不是官方维护的。 4：前端安全问题，SQL注入，跨域安全，以及其实现原理 攻击类型 XSS (Cross Site Script) 跨站脚本攻击 CSRF 跨站请求伪造 SQL注入 点击劫持 中间人攻击XSS 跨站脚本攻击 定义是指恶意攻击者利用网站没有对用户提交数据进行转义处理或者过滤不足的缺点，进而添加一些代码，嵌入到web页面中去。使得别的用户访问都会执行相应的嵌入代码。从而盗取用户资料，利用用户身份进行某种动作或者对访问者进行病毒式侵害的一种攻击方式。 攻击类型 反射型： 把用户输入的数据反射给浏览器端，攻击者诱使用户点击恶意链接，或者提交一个表单或者进入一个恶意网站，注入脚本进入会被攻击者的网站，可以获取用户隐私数据（如cookie）的脚本。 存储型： 把用户输入的数据存储在服务器端，当浏览器请求数据时，脚本从服务器上传回并执行。这种XSS攻击具有很强的稳定性。 场景：攻击者在论坛上写下一遍包含恶意JavaScript文章或评论，文章或评论发表后，所有访问该文章或评论的用户，都会在它们的浏览器中执行这段恶意的JavaScript代码。 基于DOM： 通过恶意脚本修改页面的DOM结构，是纯粹发生在客户端的攻击。 XSS防御 HttpOnly防止截取cookie 输入检查 不要相信用户的任何输入。对用户的任何输入进行检查、过滤和转义。建立可信任的字符和HTML标签白名单，对于不在白名单之列的字符或者标签进行过滤或编码。 在使用vue的 v-html 的时候需要注意，比如文章内容，这些是用户填写的，不可以直接渲染显示(用户可能会使用&lt;script src&gt;导致看这个文章的人会加载外站js从而做些不可控的事情)。 可以使用 xss 模块进行防御 v-html=$xss(test) 12345678910111213&lt;p v-html=\"$xss(test)\"&gt;&lt;/p&gt; import xss from 'xss'export default &#123; data () &#123; return &#123; test: `&lt;a onclick='alert(\"xss攻击\")'&gt;链接&lt;/a&gt;` &#125;&#125; Object.defineProperty(Vue.prototype, '$xss', &#123; value: xss&#125;) 跨站请求伪造 CSRF 攻击原理 用户登录A网站 A网站确认身份，给客户端cookie 用户在没有退出A网站的情况下，访问B网站 B网站页面向A网站发起一个请求 根据B的请求，浏览器带着产生的Cookie访问A 防御方法 GET请求不对数据进行修改 不让第三方网站访问到用户的cookie SameSite 可以对cookie设置SameSite属性。该属性设置cookie不随着跨域请求发送，该属性可以很大程度减少跨站请求伪造，但是该属性目前并不是所有浏览器都兼容。 防止第三方网站请求接口 Refere验证 通过验证Refere来判断该请求是否是第三方网站发起的，在后台接到请求的时候，可以通过请求头中的Refere请求头来判断请求来源。 使用场景：不仅防范跨站请求伪造，还可以防止图片盗链 请求时附带验证信息，比如验证码或者Token 验证码 跨站请求伪造攻击往往是在用户不知情的情况下构造了网络请求，而验证码会强制用户必须与应用进行交互，才能完成最终请求。 添加Token验证 服务器下发一个随机Token，每次发起请求时将Token携带上，服务器建立拦截器验证Token是否有效。 跟跨网站脚本（XSS）相比，XSS 利用的是用户对指定网站的信任，CSRF 利用的是网站对用户网页浏览器的信任。 SQL注入 定义： 就是通过把SQL命令插入到WEB表单提交或输入域名或页面请求的查询字符串，后台执行SQL语句时直接把前端传入的字段拿来做SQL查询。 防御： 不要使用动态SQL 避免将用户提供的输入直接放入SQL语句中 最好使用准备好的语句和参数化查询，这样更安全 不要把敏感数据保留在纯文本中 加密存储在数据库中的私有/机密数据 这样可以提供了另一级保护，以防攻击者成功地排出敏感数据。 限制数据库权限和特权 将数据库用户的功能设置为最低要求 这将限制攻击者在设法获取权限时可以执行的操作 避免直接向用户显示数据库错误 攻击者可以使用这些错误消息来获取有关数据库的信息 对访问数据库的WEB应用程序使用WEB应用程序防火墙（WAF） 这为面向Web的应用程序提供了保护，它可以帮助识别SQL注入尝试 根据设置，它还可以帮助防止SQL注入尝试到应用程序（以及数据库） 定期测试与数据交互的Web应用程序 这样做可以帮助捕获可能允许的SQL注入的新错误或回归 将数据库更新为最新的的可用修补程序 这可以防止攻击者利用旧版本存在的已知弱点/错误 点击劫持 原理：点击劫持是一种视觉欺骗的攻击手段，攻击者将需要攻击的网站通过iframe嵌套的方式嵌入到自己的网页中，并将iframe设置为透明，在页面中透出一个按钮诱导用户点击。 防御方法： X-FRAME-OPTIONS Js防御 123456// css中设置 body&#123;display:none !important;&#125; if(self == top) &#123; // window.top是读取窗口的引用 window.top是顶层窗口 document.getElementsByTagName('body')[0].style.display = 'block'; &#125;else &#123; top.location = self.location; //;localtion：该对象包含当前URL信息 拥有多个属性 &#125; 中间人攻击 原理： 中间人攻击是攻击方同时与服务端和客户端建立起了连接，并让双方认为连接是安全的，但是实际上整个通信都被攻击者控制了。 攻击者不仅能获得双方的通信信息，还能修改通信信息。 5：跨域的所有解决方案 详细引用文章 需要跨域的原因浏览器的 同源策略 SOP (same orgin policy) ，是浏览器核心最基本的安全功能。所谓同源是指 &quot;协议+域名+端口&quot; 三者相同，即便两个不同的域名指向同一个ip地址，也非同源。 跨域解决方案 jsonp document.domain + iframe跨域 location.hash + iframe跨域 window.name + iframe跨域 postMessage跨域 跨域资源共享（CORS） nginx代理跨域 nodejs 中间件代理跨域 WebSocket协议跨域jsonp跨域缺点：只能实现get请求跨域iframe的三种跨域postMessage跨域跨域资源共享（CORS）普通跨域请求：服务端设置Access-Control-Allow-Origin即可，前端无须设置，若要带cookie请求：前后端都需要设置。12// 前端设置是否带cookiewithCredentials = true; nginx代理跨域nginx配置1234567891011121314server &#123; listen 81; server_name www.domain1.com; location / &#123; proxy_pass http://www.domain2.com:8080; #反向代理 proxy_cookie_domain www.domain2.com www.domain1.com; #修改cookie里域名 index index.html index.htm; # 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用 add_header Access-Control-Allow-Origin http://www.domain1.com; #当前端只跨域不带cookie时，可为* add_header Access-Control-Allow-Credentials true; &#125;&#125; WebSocket协议跨域关键词：Scoket.io模块 6：前端项目的性能优化前端项目的性能优化手段，如果都罗列出来，可以写一本书了。。。暂时记录几个原则，日后在实际项目中遇到对应的情况再详细补充笔记 请求数量——合并脚本和样式表，CSS Sprites，拆分初始化负载，划分主域 请求带宽——开启Gzip，精简JavaScript，移除重复脚本，图像优化 缓存利用——使用CDN，使用外部JavaScript和CSS，添加Expires头，减少DNS查找，配置ETag，使Ajax可缓存 页面结构——将样式表放在顶部，将脚本放在底部，尽早刷新文档的输出 代码校验——避免CSS表达式，避免重定向 WebP图片格式vue项目中，将小图片直接转化base64，减少请求优化项目的切入点 减少客户端请求 减少服务器端响应的体积（如gzip压缩） 客户端优化 dom，css，js的代码加载顺序；或使用服务器端渲染，减少客户端渲染压力（vue中的 ssr 技术。相关链接） 网络优化，比如增加 CDN 缓存；或增加并发处理能力，比如服务端设置多个域名，客户端使用多个域名同时请求资源，增加并发量。","categories":[{"name":"Coding","slug":"Coding","permalink":"https://coryliu.github.io/Blog/blog/categories/Coding/"},{"name":"JavaScript","slug":"Coding/JavaScript","permalink":"https://coryliu.github.io/Blog/blog/categories/Coding/JavaScript/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://coryliu.github.io/Blog/blog/tags/Vue/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://coryliu.github.io/Blog/blog/tags/JavaScript/"}]},{"title":"笔记-JavaScript判断数据类型的方法总结","slug":"笔记-JavaScript判断数据类型的方法总结","date":"2020-03-11T12:22:02.000Z","updated":"2020-03-31T02:34:42.020Z","comments":true,"path":"2020/03/11/笔记-JavaScript判断数据类型的方法总结/","link":"","permalink":"https://coryliu.github.io/Blog/2020/03/11/%E7%AC%94%E8%AE%B0-JavaScript%E5%88%A4%E6%96%AD%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/","excerpt":"1: typeoftypeof 操作符返回一个字符串，表示未经计算的操作数的类型。 语法 typeof operandtypeof(operand) 注: operand [ˈɑːpərænd] n. [计] 操作数","text":"1: typeoftypeof 操作符返回一个字符串，表示未经计算的操作数的类型。 语法 typeof operandtypeof(operand) 注: operand [ˈɑːpərænd] n. [计] 操作数 参数operand 一个表示对象或原始值的表达式，其类型将被返回 描述 类型 结果 Undefined “undefined” Null “object” Boolean “boolean” Number “number” BigInt 详细 “bigint” String “string” Symbol(ES2015新增的数据类型) “symbol” Function对象 “function” 其他任何对象 “object” 注意！！！ null typeof null === ‘object’; 在 JavaScript 最初的实现中，JavaScript 中的值是由一个表示类型的标签和实际数据值表示的。对象的类型标签是 0。由于 null 代表的是空指针（大多数平台下值为 0x00），因此，null 的类型标签是 0，typeof null 也因此返回 “object”。 曾有一个 ECMAScript 的修复提案（通过选择性加入的方式），但被拒绝了。该提案会导致 typeof null === ‘null’。 new12345678910// 除 Function 外的所有构造函数的类型都是 'object'var str = new String('String');var num = new Number(100);typeof str; // 返回 'object'typeof num; // 返回 'object'var func = new Function();typeof func; // 返回 'function' 2: toStringtoString 是 object 的原型方法，调用该方法，默认返回当前对象的 Class 。对于 Object 对象，直接调用 toString() 就能返回 [object Object] 。而对于其他对象，则需要通过 call / apply 来调用才能返回正确的类型信息。 12345678910111213Object.prototype.toString.call('') ; // [object String]Object.prototype.toString.call(1) ; // [object Number]Object.prototype.toString.call(true) ; // [object Boolean]Object.prototype.toString.call(Symbol()); //[object Symbol]Object.prototype.toString.call(undefined) ; // [object Undefined]Object.prototype.toString.call(null) ; // [object Null]Object.prototype.toString.call(new Function()) ; // [object Function]Object.prototype.toString.call(new Date()) ; // [object Date]Object.prototype.toString.call([]) ; // [object Array]Object.prototype.toString.call(new RegExp()) ; // [object RegExp]Object.prototype.toString.call(new Error()) ; // [object Error]Object.prototype.toString.call(document) ; // [object HTMLDocument]Object.prototype.toString.call(window) ; //[object global] window 是全局对象 global 的引用 3: constructorconstructor 是原型 prototype 的一个属性，当函数被定义时候，js 引擎会为函数添加原型prototype，并且这个 prototype 中 constructor 属性指向函数引用， 因此重写 prototype 会丢失原来的constructor。 不过这种方法有问题： null 和 undefined 无constructor，这种方法判断不了。 如果自定义对象，开发者重写prototype之后，原有的constructor会丢失，因此，为了规范开发，在重写对象原型时一般都需要重新给 constructor 赋值，以保证对象实例的类型不被篡改。 123456789''.constructor === String //truenew Number(1).constructor === Number //truetrue.constructor === Boolean //truenew Function().constructor === Function //truenew Date().constructor === Date //truenew Error().constructor === Error //true[].constructor === Array //truedocument.constructor === HTMLDocument //truewindow.constructor === Window //true 4:instanceof字面翻译理解，instance 实例，即instanceof 是用来判断 A 是否为 B 的实例，表达式为：A instanceof B，如果 A 是 B 的实例，则返回 true,否则返回 false。 在这里需要特别注意的是：instanceof 检测的是原型 []的原型指向 Array.prototype, 间接指向 Object.prototype 12[] instanceof Array === true //true[] instanceof Object === true //也是true 所以 instanceof 只能用来判断两个对象是否属于实例关系， 而不能判断一个对象实例具体属于哪种类型。（JavaScript特殊的原型链机制）","categories":[{"name":"Coding","slug":"Coding","permalink":"https://coryliu.github.io/Blog/blog/categories/Coding/"},{"name":"JavaScript","slug":"Coding/JavaScript","permalink":"https://coryliu.github.io/Blog/blog/categories/Coding/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coryliu.github.io/Blog/blog/tags/JavaScript/"}]},{"title":"less,sass,scss笔记","slug":"less-sass-scss笔记","date":"2020-03-08T20:10:21.000Z","updated":"2020-03-31T02:34:42.020Z","comments":true,"path":"2020/03/08/less-sass-scss笔记/","link":"","permalink":"https://coryliu.github.io/Blog/2020/03/08/less-sass-scss%E7%AC%94%E8%AE%B0/","excerpt":"前言（css预处理器）好多年前，从使用bootstrap开始，就接触过less随着这些年前端技术的发展，现在越来越多的 css预处理器 被创造出来，web开发中，美工设计将不再是从前那种切图，然后生成冗长而又难以维护的css代码了其实在我的理解看来，不论是less，sass，scss还是stylus，他们的诞生就是为了让css的编写更“程序化”，就像规定了一套约定和语法，然后可以通过解释与编译成css（最终生成的必定还是css，因为浏览器只认识css啊）写下这篇笔记，梳理一下css预处理器的基础知识，方便之后自己查看","text":"前言（css预处理器）好多年前，从使用bootstrap开始，就接触过less随着这些年前端技术的发展，现在越来越多的 css预处理器 被创造出来，web开发中，美工设计将不再是从前那种切图，然后生成冗长而又难以维护的css代码了其实在我的理解看来，不论是less，sass，scss还是stylus，他们的诞生就是为了让css的编写更“程序化”，就像规定了一套约定和语法，然后可以通过解释与编译成css（最终生成的必定还是css，因为浏览器只认识css啊）写下这篇笔记，梳理一下css预处理器的基础知识，方便之后自己查看 sass按时间顺序来说，sass应该是最早出现的css预处理器 维基百科：Sass（英文全称：Syntactically Awesome Stylesheets）是一个最初由Hampton Catlin设计并由Natalie Weizenbaum开发的层叠样式表语言。在开发最初版本之后，Weizenbaum和Chris Eppstein继续通过SassScript来继续扩充Sass的功能。SassScript是一个在Sass文件中使用的小型脚本语言。 在我的理解，sass和scss其实都属于sass。最初的sass是以换行和缩进来进行书写，看起来更接近于ruby，python的感觉，文件后缀 .sass 。而后又诞生了新的语法“scss”，文件后缀 .scss，相比sass，scss的语法更接近css，因为使用花括号作为分隔。而且scss完全兼容css，这就意味着，你可以直接复制从前的css到新的.scss文件中。 less2009年出现，受SASS的影响较大，但又使用CSS的语法，让大部分开发者和设计师更容易上手，在ruby社区之外支持者远超过SASS，其缺点是比起SASS来，可编程功能不够，不过优点是简单和兼容CSS，反过来也影响了SASS演变到了SCSS的时代，著名的Twitter Bootstrap就是采用LESS做底层语言的。 相关链接 less官网 sass中文网","categories":[{"name":"Coding","slug":"Coding","permalink":"https://coryliu.github.io/Blog/blog/categories/Coding/"},{"name":"前端开发","slug":"Coding/前端开发","permalink":"https://coryliu.github.io/Blog/blog/categories/Coding/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"css","slug":"css","permalink":"https://coryliu.github.io/Blog/blog/tags/css/"}]},{"title":"关于前端工程化的理解","slug":"关于前端工程化的理解","date":"2020-02-27T17:05:13.000Z","updated":"2020-03-31T02:34:42.020Z","comments":true,"path":"2020/02/27/关于前端工程化的理解/","link":"","permalink":"https://coryliu.github.io/Blog/2020/02/27/%E5%85%B3%E4%BA%8E%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E7%9A%84%E7%90%86%E8%A7%A3/","excerpt":"前言春节期间，太久没有动手写代码，不但生疏了基础知识，连理论概念都说不出来，今天静下心来，简单总结一下 什么是前端工程化随着web业务日益复杂化和多元化，从前的前端，只是“做网页”“WebPage”而已，而如今，更像是在做一个“WebApp”。而且更多时候的需求也要求是单页面应用，这样对用户的体验会更佳，与传统的客户端程序或手机app一样。所以，前端开发，现在终于可以称得上是“软件开发”了。","text":"前言春节期间，太久没有动手写代码，不但生疏了基础知识，连理论概念都说不出来，今天静下心来，简单总结一下 什么是前端工程化随着web业务日益复杂化和多元化，从前的前端，只是“做网页”“WebPage”而已，而如今，更像是在做一个“WebApp”。而且更多时候的需求也要求是单页面应用，这样对用户的体验会更佳，与传统的客户端程序或手机app一样。所以，前端开发，现在终于可以称得上是“软件开发”了。 既然是软件开发，那么就要有软件工程的概念： 如何进行多人协作 如何保证项目的可维护性 如何让项目的开发流程可控 … 总的来说，前端开发工程化就是使用软件工程技术和方法进行前端的开发流程，技术，工具，经验等规范化，标准化。其实主要目的都是为了提高开发效率，降低维护成本，前端工程也可以是软件工程的一种。 软件工程的定义是: “应用计算机科学理论和技术以及工程管理原则和方法，按预算和进度，实现满足用户要求的软件产品的定义、开发、和维护的工程或进行研究的学科”（GB/T11457-2006《信息技术 软件工程术语》）。 前端工程化具体是如何实现的近些年，node.js的发展给前端工程化创造了条件，主要包含四个方面。“模块化”，“组件化”，“规范化”，“自动化” 1：模块化 简单来说，模块化就是把一个大文件按功能，按业务逻辑分成相互依赖的小文件，再统一拼装和加载 js的模块化在ES6之前，JavaScript一直没有模块系统。因此大多使用CommonJS，AMD，CMD完成模块的拆分和加载 用webpack+babel将所有模块打包成一个文件同步加载，也可以搭乘多个chunk异步加载； chunk表示一个文件，默认情况下webpack的输入是一个入口文件，输出也是一个文件，这个文件就是一个chunk，chunkId就是产出时给每个文件一个唯一标识id，chunkhash就是文件内容的md5值，name就是在entry中指定的key值。 用++System+Babel++主要是分模块异步加载； 用浏览器的&lt;script type=”module”&gt;加载。 css的模块化虽然SASS、LESS、Stylus等预处理器实现了CSS的文件拆分，但没有解决CSS模块化的一个重要问题：选择器的全局污染问题。 按道理，一个模块化的文件应该要隐藏内部作用域，只暴露少量接口给使用者。而按照目前预处理器的方式，导入一个CSS模块后，已存在的样式有被覆盖的风险。虽然重写样式是CSS的一个优势，但这并不利于多人协作。 为了避免全局选择器的冲突，需要制定CSS命名风格： BEM风格 Bootstrap风格 …但是这毕竟是弱约束。所以很赞同一句话： 与其费尽心思地告诉别人要遵守某种规则，以规避某种痛苦，倒不如从工具层面就消灭这种痛苦。 从工具层面，社区又创造出Shadow DOM、CSS in JS和CSS Modules三种解决方案。 Shadow DOM是WebComponents的标准。它能解决全局污染问题，但目前很多浏览器不兼容，对我们来说还很久远； CSS in JS是彻底抛弃CSS，使用JS或JSON来写样式。这种方法很激进，不能利用现有的CSS技术，而且处理伪类等问题比较困难； CSS Modules仍然使用CSS，只是让JS来管理依赖。它能够最大化地结合CSS生态和JS模块化能力，目前来看是最好的解决方案。Vue的scoped style也算是一种。(vue的scope实现原理) 资源的模块化Webpack的强大之处不仅仅在于它统一了JS的各种模块系统，取代了Browserify、RequireJS、SeaJS的工作。更重要的是它的万能模块加载理念，即所有的资源都可以且也应该模块化。资源模块化后，优点是： 依赖关系单一化。所有CSS和图片等资源的依赖关系统一走JS路线，无需额外处理CSS预处理器的依赖关系，也不需处理代码迁移时的图片合并、字体图片等路径问题； 资源处理集成化。现在可以用loader对各种资源做各种事情，比如复杂的vue-loader等等； 项目结构清晰化。使用Webpack后，你的项目结构总可以表示成这样的函数： dest = webpack(src, config)。 组件化从UI拆分下来的每个包含模板(HTML)+样式(CSS)+逻辑(JS)功能完备的结构单元，我们称之为组件。 组件化≠模块化。模块化只是在文件层面上，对代码或资源的拆分；而组件化是在设计层面上，对UI（用户界面）的拆分。 页面上所有的东西都是组件。页面是个大型组件，可以拆成若干个中型组件，然后中型组件还可以再拆，拆成若干个小型组件，小型组件也可以再拆，直到拆成DOM元素为止。DOM元素可以看成是浏览器自身的组件，作为组件的基本单元。 传统前端框架/类库的思想是先组织DOM，然后把某些可复用的逻辑封装成组件来操作DOM，是DOM优先；而组件化框架/类库的思想是先来构思组件，然后用DOM这种基本单元结合相应逻辑来实现组件，是组件优先。这是两者本质的区别。 其次，组件化实际上是一种按照模板(HTML)+样式(CSS)+逻辑(JS)三位一体的形式对面向对象的进一步抽象。 所以我们除了封装组件本身，还要合理处理组件之间的关系，比如 （逻辑）继承、（样式）扩展、（模板）嵌套和包含等，这些关系都可以归为依赖。 规范化规范化其实是工程化中很重要的一个部分，项目初期规范制定的好坏会直接影响到后期的开发质量。 比如： 目录结构的制定 目录结构的合理设定，能为项目带来很多优点： 有助于提高项目的逻辑结构合理性； 对应扩展和合作； 方便资源的统一定位管理。 规范编码 制定一套良好的编码规范可以增强团队开发协作、提高代码质量。 编码规范包括： HTML规范。 基于 W3C、苹果开发者 等官方文档，并结合团队业务和开发过程中总结的规范约定，让页面HTML代码更具语义性。 CSS规范。 统一规范团队 CSS 代码书写风格和使用 CSS 预编译语言语法风格，提供常用媒体查询语句和浏览器私有属性引用，并从业务层面统一规范常用模块的引用。 JS规范。 统一规范团队 CSS 代码书写风格和使用 CSS 预编译语言语法风格，提供常用媒体查询语句和浏览器私有属性引用，并从业务层面统一规范常用模块的引用。 图片规范。 了解各种图片格式特性，根据特性制定图片规范，包括但不限于图片的质量约定、图片引入方式、图片合并处理等，旨在从图片层面优化页面性能。 命名规范。 从 目录、图片、HTML/CSS文件、ClassName 的命名等层面约定规范团队的命名习惯，增强团队代码的可读性。 前后端接口规范 “基于 Ajax 带来的 SPA 时代”，这种模式下，前后端的分工非常清晰，前后端的关键协作点是 Ajax 接口，引发一个重要问题：前后端的对接界面双方却关注甚少，没有任何接口约定规范情况下各自撸起袖子就是干，导致我们在产品项目开发过程中，前后端的接口联调对接工作量占比在30%-50%左右，甚至会更高。往往前后端接口联调对接及系统间的联调对接都是整个产品项目研发的软肋。 接口规范主要初衷就是规范约定先行，尽量避免沟通联调产生的不必要的问题，让大家身心愉快地专注于各自擅长的领域。 那么，对于这一SPA阶段，前后端分离有几个重要的关注挑战： 职责分离 前后端仅仅通过异步接口(AJAX/JSONP)来编程； 前后端都各自有自己的开发流程，构建工具，测试集合； 关注点分离，前后端变得相对独立并松耦合。 后端 前端 提供数据 接收数据，返回数据 处理业务逻辑 处理渲染逻辑 规范原则 接口返回数据即显示，前端仅做渲染逻辑处理； 渲染逻辑禁止跨多个接口调用； 前端关注交互、渲染逻辑，尽量避免业务逻辑处理的出现； 请求响应传输数据格式：JSON，JSON数据尽量简单轻量，避免多级JSON的出现； 响应格式 响应基本格式及处理状态值的规范。 基本响应格式 列表响应格式 特殊内容 下拉框、复选框、单选框统一由后端逻辑判定选中返回给前端展示； 关于Boolean类型，JSON数据传输中一律使用1/0来标示，1为是/True，0为否/False 关于日期类型，JSON数据传输中一律使用字符串，具体日期格式因业务而定； 文档规范 组件管理 git分支管理 commit描述规范 视觉图标规范 … 自动化前端工程化的很多脏活累活都应该交给自动化工具来完成。需要秉持的一个理念是: 任何简单机械的重复劳动都应该让机器去完成。 图标合并 持续继承 自动化构建 自动化部署 自动化测试","categories":[{"name":"Coding","slug":"Coding","permalink":"https://coryliu.github.io/Blog/blog/categories/Coding/"},{"name":"Vue.js","slug":"Coding/Vue-js","permalink":"https://coryliu.github.io/Blog/blog/categories/Coding/Vue-js/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://coryliu.github.io/Blog/blog/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"记录下数组操作中的几个方法","slug":"记录下数组操作中的几个方法","date":"2020-02-11T18:30:51.000Z","updated":"2020-03-31T02:34:42.020Z","comments":true,"path":"2020/02/11/记录下数组操作中的几个方法/","link":"","permalink":"https://coryliu.github.io/Blog/2020/02/11/%E8%AE%B0%E5%BD%95%E4%B8%8B%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C%E4%B8%AD%E7%9A%84%E5%87%A0%E4%B8%AA%E6%96%B9%E6%B3%95/","excerpt":"","text":"关于数组避免使用new Array() 12var points = new Array(); // 差var points = []; // 优 原因：new 关键词只会使代码复杂化。它还会产生某些不可预期的结果： 1var points = new Array(40, 100); // 创建包含两个元素的数组（40 和 100） 加入只有一个元素 1var points = new Array(40); //创建了包含 40 个未定义元素的数组！！！ 数组操作常用方法push()12var fruits = [\"Banana\", \"Orange\", \"Apple\", \"Mango\"];fruits.push(\"Kiwi\"); // 向 fruits 添加一个新元素 shift()删除首个数组元素，并把所有其他元素“位移”到更低的索引。 12var fruits = [\"Banana\", \"Orange\", \"Apple\", \"Mango\"];fruits.shift(); // 从 fruits 删除第一个元素 \"Banana\" unshift()unshift() 方法（在开头）向数组添加新元素： 12var fruits = [\"Banana\", \"Orange\", \"Apple\", \"Mango\"];fruits.unshift(\"Lemon\"); // 向 fruits 添加新元素 \"Lemon\" splice()12var fruits = [\"Banana\", \"Orange\", \"Apple\", \"Mango\"];fruits.splice(2, 0, \"Lemon\", \"Kiwi\"); (2)表示位置(0)表示从这个位置开始要删除的个数其余表示要添加的元素 使用splice()来删除元素12var fruits = [\"Banana\", \"Orange\", \"Apple\", \"Mango\"];fruits.splice(0, 1); // 删除 fruits 中的第一个元素 concat()连接数组123var myGirls = [\"Cecilie\", \"Lone\"];var myBoys = [\"Emil\", \"Tobias\", \"Linus\"];var myChildren = myGirls.concat(myBoys); // 连接 myGirls 和 myBoys slice()截取数组12var fruits = [\"Banana\", \"Orange\", \"Lemon\", \"Apple\", \"Mango\"];var citrus = fruits.slice(1); // citrus:[ \"Orange\", \"Lemon\", \"Apple\", \"Mango\" ] slice() 可接受两个参数，比如 (1, 3)。该方法会从开始参数选取元素，直到结束参数（不包括）为止。 数据排序sort() 排序sort() 方法以字母顺序对数组进行排序 reverse() 反转数组sort()对数组数字进行排序12var points = [40, 100, 1, 5, 25, 10];points.sort(function(a, b)&#123;return a - b&#125;);","categories":[{"name":"Coding","slug":"Coding","permalink":"https://coryliu.github.io/Blog/blog/categories/Coding/"},{"name":"JavaScript","slug":"Coding/JavaScript","permalink":"https://coryliu.github.io/Blog/blog/categories/Coding/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coryliu.github.io/Blog/blog/tags/JavaScript/"},{"name":"Array","slug":"Array","permalink":"https://coryliu.github.io/Blog/blog/tags/Array/"}]},{"title":"Promise笔记","slug":"Promise笔记","date":"2020-01-31T22:48:31.000Z","updated":"2020-03-31T02:34:42.020Z","comments":true,"path":"2020/01/31/Promise笔记/","link":"","permalink":"https://coryliu.github.io/Blog/2020/01/31/Promise%E7%AC%94%E8%AE%B0/","excerpt":"","text":"使用Promise的目的Promise对延时和异步操作流进行控制 Promise状态图","categories":[{"name":"Coding","slug":"Coding","permalink":"https://coryliu.github.io/Blog/blog/categories/Coding/"},{"name":"JavaScript","slug":"Coding/JavaScript","permalink":"https://coryliu.github.io/Blog/blog/categories/Coding/JavaScript/"}],"tags":[{"name":"Promise","slug":"Promise","permalink":"https://coryliu.github.io/Blog/blog/tags/Promise/"}]},{"title":"Docker常用命令","slug":"Docker常用命令","date":"2020-01-05T12:28:07.000Z","updated":"2020-03-31T02:34:42.020Z","comments":true,"path":"2020/01/05/Docker常用命令/","link":"","permalink":"https://coryliu.github.io/Blog/2020/01/05/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","excerpt":"简单记录一下初学的内容","text":"简单记录一下初学的内容 启动容器：1$ docker run IMAGE [COMMAND] [ARG...] docker run ubuntu echo ‘hello world’ 启动交互式容器：1$ docker run -i -t IMAGE /bin/bash -i –interactive=true | false 默认 false -t –tty=true | false 默认 false 查看容器：12$ docker ps [-a] [-l]$ docker inspect [容器名字，容器id] 重新启动停止的容器：1$ docker start [-i] 容器名 进入容器【进入容器命令行】1$ docker exec -it [容器名，容器id] bash 删除停止的容器：1$ docker rm 容器id 守护式容器1$ docker run -d 镜像名 [COMMAND] [ARG...] 运行docker1$ docker run -di --name=mynginx -p 8002:80 nginx 映射本地的8002端口 进入docker容器命令行1$ docker exec -it 镜像名 /bin/bash 部署静态页面到docker 当前系统bash在vue项目的dist目录下 拷贝到名为mynginx的docker的默认html目录下1$ docker cp ./ mynginx:/usr/share/nginx/html 迁移与备份 将容器保存为镜像 1$ docker commit mynginx mynginx_i 根据镜像生成运行新容器1$ docker run -id --name=mynginx2 -p 81:80 mynginx_i 镜像导出为一个文件1$ docker save -o mynginx.tar mynginx_i 文件恢复成镜像1$ docker load -i mynginx.tar 删除镜像需要先删除此镜像生成的容器 停止容器 删除容器 删除镜像123$ docker stop 容器名$ docker rm 容器名$ docker rmi 镜像名 12$ docker ps -a //查看所有容器$ docker images //查看所有镜像 Dockerfile相当于一个构建自定义镜像的脚本 dockerfile官方文档说明","categories":[{"name":"Docker","slug":"Docker","permalink":"https://coryliu.github.io/Blog/blog/categories/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://coryliu.github.io/Blog/blog/tags/Docker/"}]},{"title":"axios拦截器实现token认证","slug":"axios拦截器实现token认证","date":"2019-12-20T12:29:47.000Z","updated":"2020-03-31T02:34:42.020Z","comments":true,"path":"2019/12/20/axios拦截器实现token认证/","link":"","permalink":"https://coryliu.github.io/Blog/2019/12/20/axios%E6%8B%A6%E6%88%AA%E5%99%A8%E5%AE%9E%E7%8E%B0token%E8%AE%A4%E8%AF%81/","excerpt":"","text":"作者：mnn链接：https://juejin.im/post/5bab739af265da0aa3593177","categories":[{"name":"Coding","slug":"Coding","permalink":"https://coryliu.github.io/Blog/blog/categories/Coding/"},{"name":"Vue.js","slug":"Coding/Vue-js","permalink":"https://coryliu.github.io/Blog/blog/categories/Coding/Vue-js/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://coryliu.github.io/Blog/blog/tags/Vue/"},{"name":"axios","slug":"axios","permalink":"https://coryliu.github.io/Blog/blog/tags/axios/"}]},{"title":"使用http-server测试vue项目","slug":"使用http-server测试vue项目","date":"2019-12-19T14:04:32.000Z","updated":"2020-03-31T02:34:42.020Z","comments":true,"path":"2019/12/19/使用http-server测试vue项目/","link":"","permalink":"https://coryliu.github.io/Blog/2019/12/19/%E4%BD%BF%E7%94%A8http-server%E6%B5%8B%E8%AF%95vue%E9%A1%B9%E7%9B%AE/","excerpt":"使用http-server测试vue打包的项目vue-cli build 打包后的项目，除了部署后预览外，也可以使用http-server快速预览。以下是详细说明：","text":"使用http-server测试vue打包的项目vue-cli build 打包后的项目，除了部署后预览外，也可以使用http-server快速预览。以下是详细说明： 项目 github 地址 http-server: a command-line http serverhttp-server is a simple, zero-configuration command-line http server. It is powerful enough for production usage, but it’s simple and hackable enough to be used for testing, local development, and learning. Installing globally:Installation via npm: npm install http-server -gThis will install http-server globally so that it may be run from the command line. Running on-demand:Using npx you can run the script without installing it first: npx http-server [path] [options]Usage:http-server [path] [options][path] defaults to ./public if the folder exists, and ./ otherwise. Now you can visit http://localhost:8080 to view your server Note: Caching is on by default. Add -c-1 as an option to disable caching. Available Options:-p or --port Port to use (defaults to 8080) -a Address to use (defaults to 0.0.0.0) -d Show directory listings (defaults to true) -i Display autoIndex (defaults to true) -g or --gzip When enabled (defaults to false) it will serve ./public/some-file.js.gz in place of ./public/some-file.js when a gzipped version of the file exists and the request accepts gzip encoding. If brotli is also enabled, it will try to serve brotli first. -b or --brotli When enabled (defaults to false) it will serve ./public/some-file.js.br in place of ./public/some-file.js when a brotli compressed version of the file exists and the request accepts br encoding. If gzip is also enabled, it will try to serve brotli first. -e or --ext Default file extension if none supplied (defaults to html) -s or --silent Suppress log messages from output --cors Enable CORS via the Access-Control-Allow-Origin header -o [path] Open browser window after starting the server. Optionally provide a URL path to open. e.g.: -o /other/dir/ -c Set cache time (in seconds) for cache-control max-age header, e.g. -c10 for 10 seconds (defaults to 3600). To disable caching, use -c-1. -U or --utc Use UTC time format in log messages. --log-ip Enable logging of the client’s IP address (default: false). -P or --proxy Proxies all requests which can’t be resolved locally to the given url. e.g.: -P http://someurl.com --username Username for basic authentication [none] --password Password for basic authentication [none] -S or --ssl Enable https. -C or --cert Path to ssl cert file (default: cert.pem). -K or --key Path to ssl key file (default: key.pem). -r or --robots Provide a /robots.txt (whose content defaults to User-agent: *\\nDisallow: /) --no-dotfiles Do not show dotfiles -h or --help Print this list and exit. -v or --version Print the version and exit. Magic Files index.html will be served as the default file to any directory requests. 404.html will be served if a file is not found. This can be used for Single-Page App (SPA) hosting to serve the entry page. Catch-all redirectTo implement a catch-all redirect, use the index page itself as the proxy with: 1http-server --proxy http:&#x2F;&#x2F;localhost:8080? Note the ? at the end of the proxy URL. Thanks to @houston3 for this clever hack! TLS/SSLFirst, you need to make sure that openssl is installed correctly, and you have key.pem and cert.pem files. You can generate them using this command: 1openssl req -newkey rsa:2048 -new -nodes -x509 -days 3650 -keyout key.pem -out cert.pem You will be prompted with a few questions after entering the command. Use 127.0.0.1 as value for Common name if you want to be able to install the certificate in your OS’s root certificate store or browser so that it is trusted. This generates a cert-key pair and it will be valid for 3650 days (about 10 years). Then you need to run the server with -S for enabling SSL and -C for your certificate file. 1http-server -S -C cert.pem This is what should be output if successful: 123456Starting up http-server, serving ./ through httpsAvailable on: https:127.0.0.1:8080 https:192.168.1.101:8080 https:192.168.1.104:8080Hit CTRL-C to stop the server DevelopmentCheckout this repository locally, then: 12$ npm i$ node bin/http-server Now you can visit http://localhost:8080 to view your server You should see the turtle image in the screenshot above hosted at that URL. Seethe ./public folder for demo content.","categories":[{"name":"Coding","slug":"Coding","permalink":"https://coryliu.github.io/Blog/blog/categories/Coding/"},{"name":"Vue.js","slug":"Coding/Vue-js","permalink":"https://coryliu.github.io/Blog/blog/categories/Coding/Vue-js/"}],"tags":[{"name":"Coding","slug":"Coding","permalink":"https://coryliu.github.io/Blog/blog/tags/Coding/"},{"name":"Node.js","slug":"Node-js","permalink":"https://coryliu.github.io/Blog/blog/tags/Node-js/"},{"name":"Vue.js","slug":"Vue-js","permalink":"https://coryliu.github.io/Blog/blog/tags/Vue-js/"}]},{"title":"JavaScript之call()与apply()","slug":"JavaScript之call","date":"2019-12-09T10:40:56.000Z","updated":"2020-03-31T02:34:42.020Z","comments":true,"path":"2019/12/09/JavaScript之call/","link":"","permalink":"https://coryliu.github.io/Blog/2019/12/09/JavaScript%E4%B9%8Bcall/","excerpt":"","text":"Function.prototype.call()call方法使用一个指定的this值和单独给出的一个或多个参数来调用一个函数。 1234567891011121314151617function Product(name, price) &#123; this.name = name; this.price = price;&#125;function Food(name, price) &#123; Product.call(this, name, price); /* 错误写法： Product(name,price) 相当于 Product.call(null,name,price)， 非严格模式下，null或者undefined会自动替换为指向全局对象，如果在浏览器下则是 window ，所以相当于Product.call(window,name,price) */ this.category = 'food';&#125;console.log(new Food('cheese', 5));// 结果: Food &#123;name: \"cheese\", price: 5, category: \"food\"&#125; MDN 文档 call Function.prototype.apply()apply() 方法调用一个具有给定this值的函数，以及作为一个数组（或类似数组对象）提供的参数。 1234567891011const numbers = [5, 6, 2, 3, 7];const max = Math.max.apply(null, numbers);console.log(max);// expected output: 7const min = Math.min.apply(null, numbers);console.log(min);// expected output: 2 备注：Math.maxmax 是 Math 的静态方法，所以直接使用：Math.max(),而不是创建的Math实例的方法(Math不是构造函数，通过typeof(Math)可以看到，Math是一个Object,没有prototype)。 语法 Math.max(value1[,value2,value3,…]) 12Math.max(numbers)//运行结果 NaN 若不使用apply()，运行结果为NaN，原因是相当于只提供了一个参数（numbers数组），max方法给定的参数无法被转换为数字，则会返回NaN。 MDN 文档 apply","categories":[{"name":"Coding","slug":"Coding","permalink":"https://coryliu.github.io/Blog/blog/categories/Coding/"},{"name":"JavaScript","slug":"Coding/JavaScript","permalink":"https://coryliu.github.io/Blog/blog/categories/Coding/JavaScript/"}],"tags":[{"name":"Coding","slug":"Coding","permalink":"https://coryliu.github.io/Blog/blog/tags/Coding/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://coryliu.github.io/Blog/blog/tags/JavaScript/"},{"name":"call","slug":"call","permalink":"https://coryliu.github.io/Blog/blog/tags/call/"}]},{"title":"从npm迁移yarn","slug":"从npm迁移yarn","date":"2019-12-04T10:22:04.000Z","updated":"2020-03-31T02:34:42.020Z","comments":true,"path":"2019/12/04/从npm迁移yarn/","link":"","permalink":"https://coryliu.github.io/Blog/2019/12/04/%E4%BB%8Enpm%E8%BF%81%E7%A7%BByarn/","excerpt":"Yarn和npm使用相同的 package.json 格式，而且从 npm 迁移 Yarn 可以从npm安装依赖包。 只需执行： 1yarn Yarn 将通过自己的解析算法来重新组织 node_modules 目录，这个算法和node.js 模块解析算法是兼容的。","text":"Yarn和npm使用相同的 package.json 格式，而且从 npm 迁移 Yarn 可以从npm安装依赖包。 只需执行： 1yarn Yarn 将通过自己的解析算法来重新组织 node_modules 目录，这个算法和node.js 模块解析算法是兼容的。 CLI命令比较 npm(v5) Yarn npm install yarn install 不适用 yarn install –flat 不适用 yarn install –har npm install –no-package-lock yarn install –no-lockfile (不适用) yarn install –pure-lockfile npm install [package] yarn add [package] npm install [package] –save-dev yarn add [package] –dev (不适用) yarn add [package] –peer npm install [package] –save-optional yarn add [package] –optional npm install [package] –save-exact yarn add [package] –exact (不适用) yarn add [package] –tilde npm install [package] –global yarn global add [package] npm update –global yarn global upgrade npm rebuild yarn install –force npm uninstall [package] yarn remove [package] npm cache clean yarn cache clean [package] rm -rf node_modules &amp;&amp; npm install yarn upgrade","categories":[{"name":"Coding","slug":"Coding","permalink":"https://coryliu.github.io/Blog/blog/categories/Coding/"},{"name":"Vue.js","slug":"Coding/Vue-js","permalink":"https://coryliu.github.io/Blog/blog/categories/Coding/Vue-js/"}],"tags":[{"name":"yarn","slug":"yarn","permalink":"https://coryliu.github.io/Blog/blog/tags/yarn/"}]},{"title":"ES6优化vue项目代码","slug":"ES6优化vue项目代码","date":"2019-12-02T09:32:54.000Z","updated":"2020-03-31T02:34:42.020Z","comments":true,"path":"2019/12/02/ES6优化vue项目代码/","link":"","permalink":"https://coryliu.github.io/Blog/2019/12/02/ES6%E4%BC%98%E5%8C%96vue%E9%A1%B9%E7%9B%AE%E4%BB%A3%E7%A0%81/","excerpt":"","text":"ES6简写123456789101112131415161718192021222324252627282930313233//没有简写&#123; method: &#123; getValue: function() &#123; //... &#125;, &#125;, computed: &#123; halfValue: function() &#123; //... &#125; &#125;, created: function() &#123; //... &#125;&#125;//使用ES6简写&#123; method: &#123; getValue() &#123; //... &#125; &#125;, computed: &#123; halfValue() &#123; //... &#125; &#125;, created() &#123; //... &#125;&#125; 解构1234567891011121314151617const person = &#123; name: 'Jake', email: 'jake@example.com', phone: '123-231-3123'&#125;//没有解构const name = person.nameconst email = person.emailconst phone = person.phone//使用解构const &#123; name, email, phone&#125; = person Vue中主要两个领域适合做解构： 从 this 中解构属性；从作用域插槽接收 prop。从this解构1234567891011121314151617181920data() &#123; return &#123; endpoint: 'example.com/api', &#125; &#125;, methods: &#123; postForm() &#123; submitForm() &#123; //没有解构 const endpoint = this.endpoint const postForm = this.postForm //使用解构 const &#123; endpoint, postForm &#125; = this &#125; &#125; &#125; 解构方式可以不用this前缀就使用这些变量，也可以清楚知道函数依赖于哪些数据和方法。 作用域插槽1234567891011&lt;!-- 不使用解构 --&gt;&lt;User v-slot=\"slotProps\"&gt; &lt;div&gt;Name: &#123;&#123; slotProps.name &#125;&#125;&lt;/div&gt; &lt;div&gt;Email: &#123;&#123; slotProps.email &#125;&#125;&lt;/div&gt;&lt;/User&gt;&lt;!-- 使用解构 --&gt;&lt;User v-slot=\"&#123;name,email&#125;\"&gt; &lt;div&gt;Name: &#123;&#123;name&#125;&#125;&lt;/div&gt; &lt;div&gt;Email: &#123;&#123;email&#125;&#125;&lt;/div&gt;&lt;/User&gt; 相比“从 this 解构”的模式，解构插槽 prop 不仅让我们可以不用 slotProps 前缀就访问变量，还向我们展示了通过插槽接收了哪些属性。 新数组方法map、排序数组、过滤数组在Vue中常用的数组方法 filter、map、forEach、includes 1234567891011121314151617//filter示例computed: &#123; //不使用数组方法 oldFilteredItems() &#123; const filtered = [] for (const item in this.items) &#123; if (item.value &gt; 10) &#123; filtered.push(item) &#125; &#125; return filtered &#125;, //使用数组方法 filteredItems() &#123; return this.items.filter((item) =&gt; item.value &gt; 10) &#125;&#125; 箭头函数12345678910data() &#123; return &#123; scrolled: false &#125;&#125;,mounted() &#123; window.addEventListener('scroll', function() &#123; this.scrolled = true &#125;)&#125; 以上代码并不工作。创建新函数的时候，this 的值会重新绑定为等于函数实例，而不是Vue实例。以下是解决方案： 123456mounted() &#123; var self = this window.addEventListener('scroll', function() &#123; self.scrolled = true &#125;)&#125; 虽然解决了问题，但是代码里var self = this 绝对难看，所以使用箭头函数解决此类问题 12345mounted() &#123; window.addEventListener('scroll', () =&gt; &#123; this.scrolled = true &#125;)&#125; 箭头函数和this的关系，参照另一篇文章ES6箭头函数，使用箭头函数替换标准函数，不会重新绑定this。 编写Vue应用的时候，注意此规则：在Vue组件中this应始终引用Vue实例。用好箭头函数的话这个目标很容易实现，这样你的代码就更容易理解了。 中文原文链接英文原文链接","categories":[{"name":"Coding","slug":"Coding","permalink":"https://coryliu.github.io/Blog/blog/categories/Coding/"},{"name":"Vue.js","slug":"Coding/Vue-js","permalink":"https://coryliu.github.io/Blog/blog/categories/Coding/Vue-js/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://coryliu.github.io/Blog/blog/tags/ES6/"},{"name":"Vue","slug":"Vue","permalink":"https://coryliu.github.io/Blog/blog/tags/Vue/"}]},{"title":"ES6箭头函数","slug":"ES6箭头函数","date":"2019-11-25T13:57:41.000Z","updated":"2020-03-31T02:34:42.020Z","comments":true,"path":"2019/11/25/ES6箭头函数/","link":"","permalink":"https://coryliu.github.io/Blog/2019/11/25/ES6%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/","excerpt":"基本用法ES6允许使用“箭头”（ =&gt; ）定义函数。 123456var f = v =&gt; v;//等同于var f = function(v) &#123; return v;&#125;;","text":"基本用法ES6允许使用“箭头”（ =&gt; ）定义函数。 123456var f = v =&gt; v;//等同于var f = function(v) &#123; return v;&#125;; 如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数的部分。 1234567891011var f = () =&gt; 5;//等同于var f = function() &#123; return 5;&#125;var sum = (num1, num2) =&gt; num1 + num2;//等同于var sum = function(num1, num2) &#123; return num1 + num2;&#125; 如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用 return 语句返回。 123var sum = (num1, num2) =&gt; &#123; return num1 + num2;&#125; 箭头函数可以与变量解构结合使用。 123456789const full = (&#123; first, last&#125;) =&gt; first + ' ' + last;// 等同于function full(person) &#123; return person.first + ' ' + person.last;&#125; 箭头函数使得表达更加简洁。 12const isEven = n =&gt; n % 2 === 0;const square = n =&gt; n * n; 箭头函数的一个用处是简化回调函数。 1234567// 正常函数写法[1, 2, 3].map(function(x) &#123; return x * x;&#125;);// 箭头函数写法[1, 2, 3].map(x =&gt; x * x); 另一个例子是 1234567// 正常函数写法var result = values.sort(function(a, b) &#123; return a - b;&#125;);// 箭头函数写法var result = values.sort((a, b) =&gt; a - b); 下面是 rest 参数与箭头函数结合的例子。 123456789const numbers = (...nums) =&gt; nums;numbers(1, 2, 3, 4, 5)// [1,2,3,4,5]const headAndTail = (head, ...tail) =&gt; [head, tail];headAndTail(1, 2, 3, 4, 5)// [1,[2,3,4,5]] 使用注意点箭头函数的几个使用注意点： 函数体内的 this 对象，就是定义时所在的对象，而不是使用时所在的对象。 不可以当作构造函数，也就是说，不可以使用 new 命令，否则会抛出一个错误。 不可以使用 argument 对象，该对象在函数体内不存在。如果要用，可以用rest参数代替。 不可以使用 yield 命令，因为箭头函数不能用作 Generator 函数。 this 对象的指向是可变的，但是在箭头函数中，它是固定的。 1234567891011function foo() &#123; setTimeout(() =&gt; &#123; console.log('id', this.id); &#125;, 100);&#125;var id = 23;foo.call(&#123; id: 42&#125;); 上面代码中， setTimeout 的参数是一个箭头函数，这个箭头函数的定义生效是在 foo 函数生成时，而它的真正执行要等到100毫秒之后。如果是普通函数，执行时 this 应该指向全局对象 window ，这时应该输出 21 。但是，箭头函数导致 this 总是指向函数定义生效时所在的对象，所以输出的是 42 。 箭头函数可以让 setTimeout 里面的 this ，绑定定义时所在的作用域，而不是指向运行时所在的作用域。下面是另一个例子。 1234567891011121314function Timer() &#123; this.s1 = 0; this.s2 = 0; //箭头函数 setInterval(() =&gt; this.s1++, 1000); //普通函数 setInterval(function() &#123; this.s2++; &#125;, 1000);&#125;var timer = new Timer()setTimeout(() =&gt; console.log('s1: ', timer.s1), 3100);setTimeout(() =&gt; console.log('s2: ', timer.s2), 3100); 上面的代码中，Timer函数内部设置了两个定时器，分别使用了箭头函数和普通函数。前者的this绑定定义时所在的作用域（即Timer函数），后者的this指向运行时所在的作用域（即全局对象）。所以，3100毫秒之后，timer.s1被更新了3次，而timer.s2一次也没有更新。","categories":[{"name":"Coding","slug":"Coding","permalink":"https://coryliu.github.io/Blog/blog/categories/Coding/"},{"name":"JavaScript","slug":"Coding/JavaScript","permalink":"https://coryliu.github.io/Blog/blog/categories/Coding/JavaScript/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://coryliu.github.io/Blog/blog/tags/ES6/"},{"name":"箭头函数","slug":"箭头函数","permalink":"https://coryliu.github.io/Blog/blog/tags/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/"}]},{"title":"vue生命周期","slug":"vue生命周期","date":"2019-11-21T14:18:40.000Z","updated":"2020-03-31T02:34:42.020Z","comments":true,"path":"2019/11/21/vue生命周期/","link":"","permalink":"https://coryliu.github.io/Blog/2019/11/21/vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/","excerpt":"","text":"","categories":[{"name":"Coding","slug":"Coding","permalink":"https://coryliu.github.io/Blog/blog/categories/Coding/"},{"name":"Vue.js","slug":"Coding/Vue-js","permalink":"https://coryliu.github.io/Blog/blog/categories/Coding/Vue-js/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://coryliu.github.io/Blog/blog/tags/Vue/"}]},{"title":"uni-app导航栏开发指南","slug":"uni-app导航栏开发指南","date":"2019-11-20T13:57:27.000Z","updated":"2020-03-31T02:34:42.020Z","comments":true,"path":"2019/11/20/uni-app导航栏开发指南/","link":"","permalink":"https://coryliu.github.io/Blog/2019/11/20/uni-app%E5%AF%BC%E8%88%AA%E6%A0%8F%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/","excerpt":"将官方社区的文章照搬过来，一方面正好在熟悉这块内容，另一方面熟练自己的md语法。原文链接https://ask.dcloud.net.cn/article/34921","text":"将官方社区的文章照搬过来，一方面正好在熟悉这块内容，另一方面熟练自己的md语法。原文链接https://ask.dcloud.net.cn/article/34921 uni-app 自带原生导航栏，在pages.json里配置。原生导航的体验更好，渲染新页面时，原生导航栏的渲染无需等待新页面dom加载，可以在新页面进入动画开始时就渲染。 原生导航还可以避免滚动条通顶，并方便的控制原生下拉刷新。通过pages.json的配置，可以简单的、跨端的、高性能的开发业务。 但原生导航栏的扩展能力有限。尤其是微信下，没有提供太多导航栏的配置。在App下，pages.json里每个页面的app-plus下可以设置titleNView等更多参数，可以得到比微信小程序更丰富的扩展性。另外，开发者也可以在必要时取消原生导航栏，使用view自行绘制导航栏。 原生导航栏的通用配置原生导航栏的配置，均在pages.json里，每个page下面的style配置中的navigationBar各个参数配置，即为通用配置，小程序、app、h5均生效。参考https://uniapp.dcloud.io/collocation/pages?id=style 全局取消原生导航栏在pages.json的globalStyle里，有个navigationStyle设置，默认是default，即带有原生导航栏。也可以设置为custom。在设为custom后，所有页面都没有原生导航。但在微信小程序里，右上角始终都有一个胶囊按钮。很多微信小游戏界面也没原生导航栏，但有胶囊按钮。一般App里不会使用这个参数配置。建议个别页面单独设置不使用原生导航，具体如下。 单独去除原生导航栏自微信客户端7.0.0起，App端HBuilderX2.0.3起，支持通过如下方法取消单独一个页面的原生导航。但小程序右上角胶囊按钮仍然去不掉。页面配置 navigationStyle 为 custom: 123456&#123; &quot;path&quot; : &quot;pages&#x2F;log.log&quot;, &quot;style&quot; : &#123; &quot;navigationStyle&quot;:&quot;custom&quot; &#125;&#125;","categories":[{"name":"Coding","slug":"Coding","permalink":"https://coryliu.github.io/Blog/blog/categories/Coding/"},{"name":"uni-app","slug":"Coding/uni-app","permalink":"https://coryliu.github.io/Blog/blog/categories/Coding/uni-app/"}],"tags":[{"name":"uni-app","slug":"uni-app","permalink":"https://coryliu.github.io/Blog/blog/tags/uni-app/"}]},{"title":"hexo写作命令","slug":"hexo写作命令","date":"2019-11-20T12:43:01.000Z","updated":"2020-03-31T02:34:42.020Z","comments":true,"path":"2019/11/20/hexo写作命令/","link":"","permalink":"https://coryliu.github.io/Blog/2019/11/20/hexo%E5%86%99%E4%BD%9C%E5%91%BD%E4%BB%A4/","excerpt":"新建文章1$ hexo new [layout] &lt;title&gt; layout : 默认为post，可以修改_config.yml中的default_layout参数来指定默认布局 布局（Layout）Hexo 有三种默认布局：post、page 和 draft。在创建这三种不同类型的文件时，它们将会被保存到不同的路径；而您自定义的其他布局和 post 相同，都将存储到 source/_posts 文件夹中。 布局 路径 post source/_posts page source draft source/_drafts 如果不希望文章被处理，可以将 Front-Matter 中的 layout: 设为 false。 预览1$ hexo server","text":"新建文章1$ hexo new [layout] &lt;title&gt; layout : 默认为post，可以修改_config.yml中的default_layout参数来指定默认布局 布局（Layout）Hexo 有三种默认布局：post、page 和 draft。在创建这三种不同类型的文件时，它们将会被保存到不同的路径；而您自定义的其他布局和 post 相同，都将存储到 source/_posts 文件夹中。 布局 路径 post source/_posts page source draft source/_drafts 如果不希望文章被处理，可以将 Front-Matter 中的 layout: 设为 false。 预览1$ hexo server","categories":[{"name":"关于博客","slug":"关于博客","permalink":"https://coryliu.github.io/Blog/blog/categories/%E5%85%B3%E4%BA%8E%E5%8D%9A%E5%AE%A2/"},{"name":"hexo命令","slug":"关于博客/hexo命令","permalink":"https://coryliu.github.io/Blog/blog/categories/%E5%85%B3%E4%BA%8E%E5%8D%9A%E5%AE%A2/hexo%E5%91%BD%E4%BB%A4/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://coryliu.github.io/Blog/blog/tags/hexo/"}]},{"title":"Nginx+uwsgi+CentOS7部署Django","slug":"Nginx-uwsgi-CentOS7部署Django","date":"2019-10-24T15:40:16.000Z","updated":"2020-03-31T02:34:42.020Z","comments":true,"path":"2019/10/24/Nginx-uwsgi-CentOS7部署Django/","link":"","permalink":"https://coryliu.github.io/Blog/2019/10/24/Nginx-uwsgi-CentOS7%E9%83%A8%E7%BD%B2Django/","excerpt":"","text":"","categories":[{"name":"Coding","slug":"Coding","permalink":"https://coryliu.github.io/Blog/blog/categories/Coding/"},{"name":"Django","slug":"Coding/Django","permalink":"https://coryliu.github.io/Blog/blog/categories/Coding/Django/"}],"tags":[{"name":"Django","slug":"Django","permalink":"https://coryliu.github.io/Blog/blog/tags/Django/"}]},{"title":"CAGED系统","slug":"CAGED系统","date":"2019-10-24T15:38:43.000Z","updated":"2020-03-31T02:34:42.020Z","comments":true,"path":"2019/10/24/CAGED系统/","link":"","permalink":"https://coryliu.github.io/Blog/2019/10/24/CAGED%E7%B3%BB%E7%BB%9F/","excerpt":"","text":"","categories":[{"name":"Guitar","slug":"Guitar","permalink":"https://coryliu.github.io/Blog/blog/categories/Guitar/"},{"name":"乐理","slug":"Guitar/乐理","permalink":"https://coryliu.github.io/Blog/blog/categories/Guitar/%E4%B9%90%E7%90%86/"}],"tags":[{"name":"乐理","slug":"乐理","permalink":"https://coryliu.github.io/Blog/blog/tags/%E4%B9%90%E7%90%86/"}]},{"title":"七和弦","slug":"七和弦","date":"2019-10-24T15:35:38.000Z","updated":"2020-03-31T02:34:42.020Z","comments":true,"path":"2019/10/24/七和弦/","link":"","permalink":"https://coryliu.github.io/Blog/2019/10/24/%E4%B8%83%E5%92%8C%E5%BC%A6/","excerpt":"七和弦的分类1. 由4个音按照三度叠加构成，根音与最高音之间成七度音程 2. 七和弦的分类：在C大调顺阶和弦中，所有的三和弦都可以变化成七和弦 常用七和弦的组成音 Maj7：1-3-5-7 (大七和弦) Dom7：1-3-5-b7 (属七和弦) min7：1-b3-5-b7 (小七和弦)","text":"七和弦的分类1. 由4个音按照三度叠加构成，根音与最高音之间成七度音程 2. 七和弦的分类：在C大调顺阶和弦中，所有的三和弦都可以变化成七和弦 常用七和弦的组成音 Maj7：1-3-5-7 (大七和弦) Dom7：1-3-5-b7 (属七和弦) min7：1-b3-5-b7 (小七和弦) 几乎所有七和弦指法(不要背，需学会自己根据音程推导)Seventh（属7） Diminished Seventh（减7） Seventh, Suspended Fourth（7挂4） Major Seventh（大7） Minor Seventh（小7） Minor，Major Seventh（小大7） Major Seventh，Flat Fifth（大7降5） Minor Seeventh，Flat Fifth（小7降5）","categories":[{"name":"Guitar","slug":"Guitar","permalink":"https://coryliu.github.io/Blog/blog/categories/Guitar/"},{"name":"乐理","slug":"Guitar/乐理","permalink":"https://coryliu.github.io/Blog/blog/categories/Guitar/%E4%B9%90%E7%90%86/"}],"tags":[{"name":"乐理","slug":"乐理","permalink":"https://coryliu.github.io/Blog/blog/tags/%E4%B9%90%E7%90%86/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-10-20T15:35:38.000Z","updated":"2020-03-31T02:34:42.020Z","comments":true,"path":"2019/10/20/hello-world/","link":"","permalink":"https://coryliu.github.io/Blog/2019/10/20/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"Coding","slug":"Coding","permalink":"https://coryliu.github.io/Blog/blog/categories/Coding/"},{"name":"Hexo","slug":"Coding/Hexo","permalink":"https://coryliu.github.io/Blog/blog/categories/Coding/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://coryliu.github.io/Blog/blog/tags/Hexo/"}]},{"title":"关于Vue中computed和watch使用场景的思考","slug":"关于Vue中computed和watch使用场景的思考","date":"2019-10-16T14:09:45.000Z","updated":"2020-03-31T02:34:42.020Z","comments":true,"path":"2019/10/16/关于Vue中computed和watch使用场景的思考/","link":"","permalink":"https://coryliu.github.io/Blog/2019/10/16/%E5%85%B3%E4%BA%8EVue%E4%B8%ADcomputed%E5%92%8Cwatch%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E7%9A%84%E6%80%9D%E8%80%83/","excerpt":"","text":"为何需要计算属性（computed）123&lt;div id=\"example\"&gt; &#123;&#123; message.split('').reverse().join('') &#125;&#125;&lt;/div&gt; 需要对data进行一些简单的计算与操作的时候，如上代码，直接在模板中放入逻辑。假如这个操作比较复杂，则对于页面后续的维护不易。假如页面中多个地方都需要进行相同的计算，那岂不是都需要复制一遍，当计算规则改变时，岂不是每个地方都需要进行修改。那么这种方式明显是不合适的。所以vue提供了计算属性这一特性： 基础例子1234&lt;div id=\"example\"&gt; &lt;p&gt;Original message: \"&#123;&#123; message &#125;&#125;\"&lt;/p&gt; &lt;p&gt;Computed reversed message: \"&#123;&#123; reversedMessage &#125;&#125;\"&lt;/p&gt;&lt;/div&gt; 12345678910111213var vm = new Vue(&#123; el: '#example', data: &#123; message: 'Hello' &#125;, computed: &#123; // 计算属性的 getter reversedMessage: function () &#123; // `this` 指向 vm 实例 return this.message.split('').reverse().join('') &#125; &#125;&#125;) vm.reversedMessage依赖于vm.message，所以当vm.message发生改变的时候，所有依赖vm.reverseMessage的绑定也会更新。 注意：与直接在模板中使用method的方式比较，使用computed只有在依赖的数据发生改变时才会进行计算，也就是它是有缓存的，使用method，则每次访问reverseMessage都将进行一次新的计算。这无疑对性能是不好的。 侦听属性（watch）vue官方的说法是，在需要数据变化的时候执行异步或开销较大的操作时(在computed中无法做到异步操作，异步函数执行之后，回调函数中返回值并不会触发dom的重新渲染)，使用watch 异步ajax请求的发起，可以使用 Lodash 模块的 _.debounce 进行请求发起的间隔，防止修改数据过于频繁，导致ajax请求无限发送，影响性能。","categories":[{"name":"Coding","slug":"Coding","permalink":"https://coryliu.github.io/Blog/blog/categories/Coding/"},{"name":"Vue.js","slug":"Coding/Vue-js","permalink":"https://coryliu.github.io/Blog/blog/categories/Coding/Vue-js/"}],"tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://coryliu.github.io/Blog/blog/tags/Vue-js/"}]}]}