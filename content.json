{"meta":{"title":"阿b的Blog","subtitle":"因为夹娃娃很疗愈啊","description":null,"author":"Liu","url":"https://coryliu.github.io/Blog","root":"/Blog/"},"pages":[{"title":"404 Not Found","date":"2020-01-05T06:30:18.547Z","updated":"2020-01-05T06:30:18.547Z","comments":true,"path":"404.html","permalink":"https://coryliu.github.io/Blog/404.html","excerpt":"","text":"404 Not Found **很抱歉，您访问的页面不存在** 可能是输入地址有误或该地址已被删除"},{"title":"关于","date":"2020-01-05T06:30:18.547Z","updated":"2020-01-05T06:30:18.547Z","comments":true,"path":"about/index.html","permalink":"https://coryliu.github.io/Blog/about/index.html","excerpt":"","text":"关于主题本站主题是：Material X One More Thing懒加载占位图如果喜欢请拿去：图片链接 我的沙雕航拍"},{"title":"","date":"2020-01-05T06:30:18.547Z","updated":"2020-01-05T06:30:18.547Z","comments":true,"path":"friends/index.html","permalink":"https://coryliu.github.io/Blog/friends/index.html","excerpt":"","text":"这个人很孤独，木得盆友 名称： abin’s blog头像： https://cdn.jsdelivr.net/gh/CoryLiu/Img-repo@master/static_files/lyb/img/avatar头像.jpg网址： https://coryliu.github.io/Blog/标签： hexo"},{"title":"","date":"2020-01-05T06:30:18.547Z","updated":"2020-01-05T06:30:18.547Z","comments":true,"path":"projects/index.html","permalink":"https://coryliu.github.io/Blog/projects/index.html","excerpt":"","text":""},{"title":"所有分类","date":"2020-01-05T06:30:18.547Z","updated":"2020-01-05T06:30:18.547Z","comments":true,"path":"blog/categories/index.html","permalink":"https://coryliu.github.io/Blog/blog/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2020-01-05T06:30:18.547Z","updated":"2020-01-05T06:30:18.547Z","comments":true,"path":"blog/tags/index.html","permalink":"https://coryliu.github.io/Blog/blog/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Docker常用命令","slug":"Docker常用命令","date":"2020-01-05T12:28:07.000Z","updated":"2020-01-05T06:30:18.547Z","comments":true,"path":"2020/01/05/Docker常用命令/","link":"","permalink":"https://coryliu.github.io/Blog/2020/01/05/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","excerpt":"","text":"启动容器：1$ docker run IMAGE [COMMAND] [ARG...] docker run ubuntu echo ‘hello world’ 启动交互式容器：1$ docker run -i -t IMAGE /bin/bash -i –interactive=true | false 默认 false -t –tty=true | false 默认 false 查看容器：12$ docker ps [-a] [-l]$ docker inspect [容器名字，容器id] 重新启动停止的容器：1$ docker start [-i] 容器名 删除停止的容器：1$ docker rm 容器id 守护式容器1$ docker run -d 镜像名 [COMMAND] [ARG...] 运行docker1$ docker run -di --name=mynginx -p 8002:80 nginx 映射本地的8002端口 进入docker容器命令行1$ docker exec -it 镜像名 /bin/bash 部署静态页面到docker 当前系统bash在vue项目的dist目录下 拷贝到名为mynginx的docker的默认html目录下1$ docker cp ./ mynginx:/usr/share/nginx/html 迁移与备份 将容器保存为镜像 1$ docker commit mynginx mynginx_i 根据镜像生成运行新容器1$ docker run -id --name=mynginx2 -p 81:80 mynginx_i 镜像导出为一个文件1$ docker save -o mynginx.tar mynginx_i 文件恢复成镜像1$ docker load -i mynginx.tar 删除镜像需要先删除此镜像生成的容器 停止容器 删除容器 删除镜像123$ docker stop 容器名$ docker rm 容器名$ docker rmi 镜像名 12$ docker ps -a //查看所有容器$ docker images //查看所有镜像 Dockerfile相当于一个构建自定义镜像的脚本 dockerfile官方文档说明","categories":[{"name":"Docker","slug":"Docker","permalink":"https://coryliu.github.io/Blog/blog/categories/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://coryliu.github.io/Blog/blog/tags/Docker/"}]},{"title":"axios拦截器实现token认证","slug":"axios拦截器实现token认证","date":"2019-12-20T12:29:47.000Z","updated":"2020-01-05T06:30:18.547Z","comments":true,"path":"2019/12/20/axios拦截器实现token认证/","link":"","permalink":"https://coryliu.github.io/Blog/2019/12/20/axios%E6%8B%A6%E6%88%AA%E5%99%A8%E5%AE%9E%E7%8E%B0token%E8%AE%A4%E8%AF%81/","excerpt":"","text":"作者：mnn链接：https://juejin.im/post/5bab739af265da0aa3593177","categories":[{"name":"Coding","slug":"Coding","permalink":"https://coryliu.github.io/Blog/blog/categories/Coding/"},{"name":"Vue.js","slug":"Coding/Vue-js","permalink":"https://coryliu.github.io/Blog/blog/categories/Coding/Vue-js/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://coryliu.github.io/Blog/blog/tags/Vue/"},{"name":"axios","slug":"axios","permalink":"https://coryliu.github.io/Blog/blog/tags/axios/"}]},{"title":"使用http-server测试vue项目","slug":"使用http-server测试vue项目","date":"2019-12-19T14:04:32.000Z","updated":"2020-01-05T06:30:18.547Z","comments":true,"path":"2019/12/19/使用http-server测试vue项目/","link":"","permalink":"https://coryliu.github.io/Blog/2019/12/19/%E4%BD%BF%E7%94%A8http-server%E6%B5%8B%E8%AF%95vue%E9%A1%B9%E7%9B%AE/","excerpt":"使用http-server测试vue打包的项目vue-cli build 打包后的项目，除了部署后预览外，也可以使用http-server快速预览。以下是详细说明：","text":"使用http-server测试vue打包的项目vue-cli build 打包后的项目，除了部署后预览外，也可以使用http-server快速预览。以下是详细说明： 项目 github 地址 http-server: a command-line http serverhttp-server is a simple, zero-configuration command-line http server. It is powerful enough for production usage, but it’s simple and hackable enough to be used for testing, local development, and learning. Installing globally:Installation via npm: npm install http-server -gThis will install http-server globally so that it may be run from the command line. Running on-demand:Using npx you can run the script without installing it first: npx http-server [path] [options]Usage:http-server [path] [options][path] defaults to ./public if the folder exists, and ./ otherwise. Now you can visit http://localhost:8080 to view your server Note: Caching is on by default. Add -c-1 as an option to disable caching. Available Options:-p or --port Port to use (defaults to 8080) -a Address to use (defaults to 0.0.0.0) -d Show directory listings (defaults to true) -i Display autoIndex (defaults to true) -g or --gzip When enabled (defaults to false) it will serve ./public/some-file.js.gz in place of ./public/some-file.js when a gzipped version of the file exists and the request accepts gzip encoding. If brotli is also enabled, it will try to serve brotli first. -b or --brotli When enabled (defaults to false) it will serve ./public/some-file.js.br in place of ./public/some-file.js when a brotli compressed version of the file exists and the request accepts br encoding. If gzip is also enabled, it will try to serve brotli first. -e or --ext Default file extension if none supplied (defaults to html) -s or --silent Suppress log messages from output --cors Enable CORS via the Access-Control-Allow-Origin header -o [path] Open browser window after starting the server. Optionally provide a URL path to open. e.g.: -o /other/dir/ -c Set cache time (in seconds) for cache-control max-age header, e.g. -c10 for 10 seconds (defaults to 3600). To disable caching, use -c-1. -U or --utc Use UTC time format in log messages. --log-ip Enable logging of the client’s IP address (default: false). -P or --proxy Proxies all requests which can’t be resolved locally to the given url. e.g.: -P http://someurl.com --username Username for basic authentication [none] --password Password for basic authentication [none] -S or --ssl Enable https. -C or --cert Path to ssl cert file (default: cert.pem). -K or --key Path to ssl key file (default: key.pem). -r or --robots Provide a /robots.txt (whose content defaults to User-agent: *\\nDisallow: /) --no-dotfiles Do not show dotfiles -h or --help Print this list and exit. -v or --version Print the version and exit. Magic Files index.html will be served as the default file to any directory requests. 404.html will be served if a file is not found. This can be used for Single-Page App (SPA) hosting to serve the entry page. Catch-all redirectTo implement a catch-all redirect, use the index page itself as the proxy with: 1http-server --proxy http://localhost:8080? Note the ? at the end of the proxy URL. Thanks to @houston3 for this clever hack! TLS/SSLFirst, you need to make sure that openssl is installed correctly, and you have key.pem and cert.pem files. You can generate them using this command: 1openssl req -newkey rsa:2048 -new -nodes -x509 -days 3650 -keyout key.pem -out cert.pem You will be prompted with a few questions after entering the command. Use 127.0.0.1 as value for Common name if you want to be able to install the certificate in your OS’s root certificate store or browser so that it is trusted. This generates a cert-key pair and it will be valid for 3650 days (about 10 years). Then you need to run the server with -S for enabling SSL and -C for your certificate file. 1http-server -S -C cert.pem This is what should be output if successful: 123456Starting up http-server, serving ./ through httpsAvailable on: https:127.0.0.1:8080 https:192.168.1.101:8080 https:192.168.1.104:8080Hit CTRL-C to stop the server DevelopmentCheckout this repository locally, then: 12$ npm i$ node bin/http-server Now you can visit http://localhost:8080 to view your server You should see the turtle image in the screenshot above hosted at that URL. Seethe ./public folder for demo content.","categories":[{"name":"Coding","slug":"Coding","permalink":"https://coryliu.github.io/Blog/blog/categories/Coding/"},{"name":"Vue.js","slug":"Coding/Vue-js","permalink":"https://coryliu.github.io/Blog/blog/categories/Coding/Vue-js/"}],"tags":[{"name":"Coding","slug":"Coding","permalink":"https://coryliu.github.io/Blog/blog/tags/Coding/"},{"name":"Vue.js","slug":"Vue-js","permalink":"https://coryliu.github.io/Blog/blog/tags/Vue-js/"},{"name":"Node.js","slug":"Node-js","permalink":"https://coryliu.github.io/Blog/blog/tags/Node-js/"}]},{"title":"JavaScript之call()与apply()","slug":"JavaScript之call","date":"2019-12-09T10:40:56.000Z","updated":"2020-01-05T06:30:18.547Z","comments":true,"path":"2019/12/09/JavaScript之call/","link":"","permalink":"https://coryliu.github.io/Blog/2019/12/09/JavaScript%E4%B9%8Bcall/","excerpt":"","text":"Function.prototype.call()call方法使用一个指定的this值和单独给出的一个或多个参数来调用一个函数。 1234567891011121314151617function Product(name, price) &#123; this.name = name; this.price = price;&#125;function Food(name, price) &#123; Product.call(this, name, price); /* 错误写法： Product(name,price) 相当于 Product.call(null,name,price)， 非严格模式下，null或者undefined会自动替换为指向全局对象，如果在浏览器下则是 window ，所以相当于Product.call(window,name,price) */ this.category = 'food';&#125;console.log(new Food('cheese', 5));// 结果: Food &#123;name: \"cheese\", price: 5, category: \"food\"&#125; MDN 文档 call Function.prototype.apply()apply() 方法调用一个具有给定this值的函数，以及作为一个数组（或类似数组对象）提供的参数。 1234567891011const numbers = [5, 6, 2, 3, 7];const max = Math.max.apply(null, numbers);console.log(max);// expected output: 7const min = Math.min.apply(null, numbers);console.log(min);// expected output: 2 备注：Math.maxmax 是 Math 的静态方法，所以直接使用：Math.max(),而不是创建的Math实例的方法(Math不是构造函数，通过typeof(Math)可以看到，Math是一个Object,没有prototype)。 语法 Math.max(value1[,value2,value3,…]) 12Math.max(numbers)//运行结果 NaN 若不使用apply()，运行结果为NaN，原因是相当于只提供了一个参数（numbers数组），max方法给定的参数无法被转换为数字，则会返回NaN。 MDN 文档 apply","categories":[{"name":"Coding","slug":"Coding","permalink":"https://coryliu.github.io/Blog/blog/categories/Coding/"},{"name":"JavaScript","slug":"Coding/JavaScript","permalink":"https://coryliu.github.io/Blog/blog/categories/Coding/JavaScript/"}],"tags":[{"name":"Coding","slug":"Coding","permalink":"https://coryliu.github.io/Blog/blog/tags/Coding/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://coryliu.github.io/Blog/blog/tags/JavaScript/"},{"name":"call","slug":"call","permalink":"https://coryliu.github.io/Blog/blog/tags/call/"}]},{"title":"从npm迁移yarn","slug":"从npm迁移yarn","date":"2019-12-04T10:22:04.000Z","updated":"2020-01-05T06:30:18.547Z","comments":true,"path":"2019/12/04/从npm迁移yarn/","link":"","permalink":"https://coryliu.github.io/Blog/2019/12/04/%E4%BB%8Enpm%E8%BF%81%E7%A7%BByarn/","excerpt":"Yarn和npm使用相同的 package.json 格式，而且从 npm 迁移 Yarn 可以从npm安装依赖包。 只需执行： 1yarn Yarn 将通过自己的解析算法来重新组织 node_modules 目录，这个算法和node.js 模块解析算法是兼容的。","text":"Yarn和npm使用相同的 package.json 格式，而且从 npm 迁移 Yarn 可以从npm安装依赖包。 只需执行： 1yarn Yarn 将通过自己的解析算法来重新组织 node_modules 目录，这个算法和node.js 模块解析算法是兼容的。 CLI命令比较 npm(v5) Yarn npm install yarn install 不适用 yarn install –flat 不适用 yarn install –har npm install –no-package-lock yarn install –no-lockfile (不适用) yarn install –pure-lockfile npm install [package] yarn add [package] npm install [package] –save-dev yarn add [package] –dev (不适用) yarn add [package] –peer npm install [package] –save-optional yarn add [package] –optional npm install [package] –save-exact yarn add [package] –exact (不适用) yarn add [package] –tilde npm install [package] –global yarn global add [package] npm update –global yarn global upgrade npm rebuild yarn install –force npm uninstall [package] yarn remove [package] npm cache clean yarn cache clean [package] rm -rf node_modules &amp;&amp; npm install yarn upgrade","categories":[{"name":"Coding","slug":"Coding","permalink":"https://coryliu.github.io/Blog/blog/categories/Coding/"},{"name":"Vue.js","slug":"Coding/Vue-js","permalink":"https://coryliu.github.io/Blog/blog/categories/Coding/Vue-js/"}],"tags":[{"name":"yarn","slug":"yarn","permalink":"https://coryliu.github.io/Blog/blog/tags/yarn/"}]},{"title":"ES6优化vue项目代码","slug":"ES6优化vue项目代码","date":"2019-12-02T09:32:54.000Z","updated":"2020-01-05T06:30:18.547Z","comments":true,"path":"2019/12/02/ES6优化vue项目代码/","link":"","permalink":"https://coryliu.github.io/Blog/2019/12/02/ES6%E4%BC%98%E5%8C%96vue%E9%A1%B9%E7%9B%AE%E4%BB%A3%E7%A0%81/","excerpt":"","text":"ES6简写123456789101112131415161718192021222324252627282930313233//没有简写&#123; method: &#123; getValue: function() &#123; //... &#125;, &#125;, computed: &#123; halfValue: function() &#123; //... &#125; &#125;, created: function() &#123; //... &#125;&#125;//使用ES6简写&#123; method: &#123; getValue() &#123; //... &#125; &#125;, computed: &#123; halfValue() &#123; //... &#125; &#125;, created() &#123; //... &#125;&#125; 解构1234567891011121314151617const person = &#123; name: 'Jake', email: 'jake@example.com', phone: '123-231-3123'&#125;//没有解构const name = person.nameconst email = person.emailconst phone = person.phone//使用解构const &#123; name, email, phone&#125; = person Vue中主要两个领域适合做解构： 从 this 中解构属性；从作用域插槽接收 prop。从this解构1234567891011121314151617181920data() &#123; return &#123; endpoint: 'example.com/api', &#125; &#125;, methods: &#123; postForm() &#123; submitForm() &#123; //没有解构 const endpoint = this.endpoint const postForm = this.postForm //使用解构 const &#123; endpoint, postForm &#125; = this &#125; &#125; &#125; 解构方式可以不用this前缀就使用这些变量，也可以清楚知道函数依赖于哪些数据和方法。 作用域插槽1234567891011&lt;!-- 不使用解构 --&gt;&lt;User v-slot=\"slotProps\"&gt; &lt;div&gt;Name: &#123;&#123; slotProps.name &#125;&#125;&lt;/div&gt; &lt;div&gt;Email: &#123;&#123; slotProps.email &#125;&#125;&lt;/div&gt;&lt;/User&gt;&lt;!-- 使用解构 --&gt;&lt;User v-slot=\"&#123;name,email&#125;\"&gt; &lt;div&gt;Name: &#123;&#123;name&#125;&#125;&lt;/div&gt; &lt;div&gt;Email: &#123;&#123;email&#125;&#125;&lt;/div&gt;&lt;/User&gt; 相比“从 this 解构”的模式，解构插槽 prop 不仅让我们可以不用 slotProps 前缀就访问变量，还向我们展示了通过插槽接收了哪些属性。 新数组方法map、排序数组、过滤数组在Vue中常用的数组方法 filter、map、forEach、includes 1234567891011121314151617//filter示例computed: &#123; //不使用数组方法 oldFilteredItems() &#123; const filtered = [] for (const item in this.items) &#123; if (item.value &gt; 10) &#123; filtered.push(item) &#125; &#125; return filtered &#125;, //使用数组方法 filteredItems() &#123; return this.items.filter((item) =&gt; item.value &gt; 10) &#125;&#125; 箭头函数12345678910data() &#123; return &#123; scrolled: false &#125;&#125;,mounted() &#123; window.addEventListener('scroll', function() &#123; this.scrolled = true &#125;)&#125; 以上代码并不工作。创建新函数的时候，this 的值会重新绑定为等于函数实例，而不是Vue实例。以下是解决方案： 123456mounted() &#123; var self = this window.addEventListener('scroll', function() &#123; self.scrolled = true &#125;)&#125; 虽然解决了问题，但是代码里var self = this 绝对难看，所以使用箭头函数解决此类问题 12345mounted() &#123; window.addEventListener('scroll', () =&gt; &#123; this.scrolled = true &#125;)&#125; 箭头函数和this的关系，参照另一篇文章ES6箭头函数，使用箭头函数替换标准函数，不会重新绑定this。 编写Vue应用的时候，注意此规则：在Vue组件中this应始终引用Vue实例。用好箭头函数的话这个目标很容易实现，这样你的代码就更容易理解了。 中文原文链接英文原文链接","categories":[{"name":"Coding","slug":"Coding","permalink":"https://coryliu.github.io/Blog/blog/categories/Coding/"},{"name":"Vue.js","slug":"Coding/Vue-js","permalink":"https://coryliu.github.io/Blog/blog/categories/Coding/Vue-js/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://coryliu.github.io/Blog/blog/tags/ES6/"},{"name":"Vue","slug":"Vue","permalink":"https://coryliu.github.io/Blog/blog/tags/Vue/"}]},{"title":"ES6箭头函数","slug":"ES6箭头函数","date":"2019-11-25T13:57:41.000Z","updated":"2020-01-05T06:30:18.547Z","comments":true,"path":"2019/11/25/ES6箭头函数/","link":"","permalink":"https://coryliu.github.io/Blog/2019/11/25/ES6%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/","excerpt":"基本用法ES6允许使用“箭头”（ =&gt; ）定义函数。 123456var f = v =&gt; v;//等同于var f = function(v) &#123; return v;&#125;;","text":"基本用法ES6允许使用“箭头”（ =&gt; ）定义函数。 123456var f = v =&gt; v;//等同于var f = function(v) &#123; return v;&#125;; 如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数的部分。 1234567891011var f = () =&gt; 5;//等同于var f = function() &#123; return 5;&#125;var sum = (num1, num2) =&gt; num1 + num2;//等同于var sum = function(num1, num2) &#123; return num1 + num2;&#125; 如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用 return 语句返回。 123var sum = (num1, num2) =&gt; &#123; return num1 + num2;&#125; 箭头函数可以与变量解构结合使用。 123456789const full = (&#123; first, last&#125;) =&gt; first + ' ' + last;// 等同于function full(person) &#123; return person.first + ' ' + person.last;&#125; 箭头函数使得表达更加简洁。 12const isEven = n =&gt; n % 2 === 0;const square = n =&gt; n * n; 箭头函数的一个用处是简化回调函数。 1234567// 正常函数写法[1, 2, 3].map(function(x) &#123; return x * x;&#125;);// 箭头函数写法[1, 2, 3].map(x =&gt; x * x); 另一个例子是 1234567// 正常函数写法var result = values.sort(function(a, b) &#123; return a - b;&#125;);// 箭头函数写法var result = values.sort((a, b) =&gt; a - b); 下面是 rest 参数与箭头函数结合的例子。 123456789const numbers = (...nums) =&gt; nums;numbers(1, 2, 3, 4, 5)// [1,2,3,4,5]const headAndTail = (head, ...tail) =&gt; [head, tail];headAndTail(1, 2, 3, 4, 5)// [1,[2,3,4,5]] 使用注意点箭头函数的几个使用注意点： 函数体内的 this 对象，就是定义时所在的对象，而不是使用时所在的对象。 不可以当作构造函数，也就是说，不可以使用 new 命令，否则会抛出一个错误。 不可以使用 argument 对象，该对象在函数体内不存在。如果要用，可以用rest参数代替。 不可以使用 yield 命令，因为箭头函数不能用作 Generator 函数。 this 对象的指向是可变的，但是在箭头函数中，它是固定的。 1234567891011function foo() &#123; setTimeout(() =&gt; &#123; console.log('id', this.id); &#125;, 100);&#125;var id = 23;foo.call(&#123; id: 42&#125;); 上面代码中， setTimeout 的参数是一个箭头函数，这个箭头函数的定义生效是在 foo 函数生成时，而它的真正执行要等到100毫秒之后。如果是普通函数，执行时 this 应该指向全局对象 window ，这时应该输出 21 。但是，箭头函数导致 this 总是指向函数定义生效时所在的对象，所以输出的是 42 。 箭头函数可以让 setTimeout 里面的 this ，绑定定义时所在的作用域，而不是指向运行时所在的作用域。下面是另一个例子。 1234567891011121314function Timer() &#123; this.s1 = 0; this.s2 = 0; //箭头函数 setInterval(() =&gt; this.s1++, 1000); //普通函数 setInterval(function() &#123; this.s2++; &#125;, 1000);&#125;var timer = new Timer()setTimeout(() =&gt; console.log('s1: ', timer.s1), 3100);setTimeout(() =&gt; console.log('s2: ', timer.s2), 3100); 上面的代码中，Timer函数内部设置了两个定时器，分别使用了箭头函数和普通函数。前者的this绑定定义时所在的作用域（即Timer函数），后者的this指向运行时所在的作用域（即全局对象）。所以，3100毫秒之后，timer.s1被更新了3次，而timer.s2一次也没有更新。","categories":[{"name":"Coding","slug":"Coding","permalink":"https://coryliu.github.io/Blog/blog/categories/Coding/"},{"name":"JavaScript","slug":"Coding/JavaScript","permalink":"https://coryliu.github.io/Blog/blog/categories/Coding/JavaScript/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://coryliu.github.io/Blog/blog/tags/ES6/"},{"name":"箭头函数","slug":"箭头函数","permalink":"https://coryliu.github.io/Blog/blog/tags/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/"}]},{"title":"vue生命周期","slug":"vue生命周期","date":"2019-11-21T14:18:40.000Z","updated":"2020-01-05T06:30:18.547Z","comments":true,"path":"2019/11/21/vue生命周期/","link":"","permalink":"https://coryliu.github.io/Blog/2019/11/21/vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/","excerpt":"","text":"","categories":[{"name":"Coding","slug":"Coding","permalink":"https://coryliu.github.io/Blog/blog/categories/Coding/"},{"name":"Vue.js","slug":"Coding/Vue-js","permalink":"https://coryliu.github.io/Blog/blog/categories/Coding/Vue-js/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://coryliu.github.io/Blog/blog/tags/Vue/"}]},{"title":"uni-app导航栏开发指南","slug":"uni-app导航栏开发指南","date":"2019-11-20T13:57:27.000Z","updated":"2020-01-05T06:30:18.547Z","comments":true,"path":"2019/11/20/uni-app导航栏开发指南/","link":"","permalink":"https://coryliu.github.io/Blog/2019/11/20/uni-app%E5%AF%BC%E8%88%AA%E6%A0%8F%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/","excerpt":"将官方社区的文章照搬过来，一方面正好在熟悉这块内容，另一方面熟练自己的md语法。原文链接https://ask.dcloud.net.cn/article/34921","text":"将官方社区的文章照搬过来，一方面正好在熟悉这块内容，另一方面熟练自己的md语法。原文链接https://ask.dcloud.net.cn/article/34921 uni-app 自带原生导航栏，在pages.json里配置。原生导航的体验更好，渲染新页面时，原生导航栏的渲染无需等待新页面dom加载，可以在新页面进入动画开始时就渲染。 原生导航还可以避免滚动条通顶，并方便的控制原生下拉刷新。通过pages.json的配置，可以简单的、跨端的、高性能的开发业务。 但原生导航栏的扩展能力有限。尤其是微信下，没有提供太多导航栏的配置。在App下，pages.json里每个页面的app-plus下可以设置titleNView等更多参数，可以得到比微信小程序更丰富的扩展性。另外，开发者也可以在必要时取消原生导航栏，使用view自行绘制导航栏。 原生导航栏的通用配置原生导航栏的配置，均在pages.json里，每个page下面的style配置中的navigationBar各个参数配置，即为通用配置，小程序、app、h5均生效。参考https://uniapp.dcloud.io/collocation/pages?id=style 全局取消原生导航栏在pages.json的globalStyle里，有个navigationStyle设置，默认是default，即带有原生导航栏。也可以设置为custom。在设为custom后，所有页面都没有原生导航。但在微信小程序里，右上角始终都有一个胶囊按钮。很多微信小游戏界面也没原生导航栏，但有胶囊按钮。一般App里不会使用这个参数配置。建议个别页面单独设置不使用原生导航，具体如下。 单独去除原生导航栏自微信客户端7.0.0起，App端HBuilderX2.0.3起，支持通过如下方法取消单独一个页面的原生导航。但小程序右上角胶囊按钮仍然去不掉。页面配置 navigationStyle 为 custom: 123456&#123; &quot;path&quot; : &quot;pages/log.log&quot;, &quot;style&quot; : &#123; &quot;navigationStyle&quot;:&quot;custom&quot; &#125;&#125;","categories":[{"name":"Coding","slug":"Coding","permalink":"https://coryliu.github.io/Blog/blog/categories/Coding/"},{"name":"uni-app","slug":"Coding/uni-app","permalink":"https://coryliu.github.io/Blog/blog/categories/Coding/uni-app/"}],"tags":[{"name":"uni-app","slug":"uni-app","permalink":"https://coryliu.github.io/Blog/blog/tags/uni-app/"}]},{"title":"hexo写作命令","slug":"hexo写作命令","date":"2019-11-20T12:43:01.000Z","updated":"2020-01-05T06:30:18.547Z","comments":true,"path":"2019/11/20/hexo写作命令/","link":"","permalink":"https://coryliu.github.io/Blog/2019/11/20/hexo%E5%86%99%E4%BD%9C%E5%91%BD%E4%BB%A4/","excerpt":"新建文章1$ hexo new [layout] &lt;title&gt; layout : 默认为post，可以修改_config.yml中的default_layout参数来指定默认布局 布局（Layout）Hexo 有三种默认布局：post、page 和 draft。在创建这三种不同类型的文件时，它们将会被保存到不同的路径；而您自定义的其他布局和 post 相同，都将存储到 source/_posts 文件夹中。 布局 路径 post source/_posts page source draft source/_drafts 如果不希望文章被处理，可以将 Front-Matter 中的 layout: 设为 false。 预览1$ hexo server","text":"新建文章1$ hexo new [layout] &lt;title&gt; layout : 默认为post，可以修改_config.yml中的default_layout参数来指定默认布局 布局（Layout）Hexo 有三种默认布局：post、page 和 draft。在创建这三种不同类型的文件时，它们将会被保存到不同的路径；而您自定义的其他布局和 post 相同，都将存储到 source/_posts 文件夹中。 布局 路径 post source/_posts page source draft source/_drafts 如果不希望文章被处理，可以将 Front-Matter 中的 layout: 设为 false。 预览1$ hexo server","categories":[{"name":"关于博客","slug":"关于博客","permalink":"https://coryliu.github.io/Blog/blog/categories/%E5%85%B3%E4%BA%8E%E5%8D%9A%E5%AE%A2/"},{"name":"hexo命令","slug":"关于博客/hexo命令","permalink":"https://coryliu.github.io/Blog/blog/categories/%E5%85%B3%E4%BA%8E%E5%8D%9A%E5%AE%A2/hexo%E5%91%BD%E4%BB%A4/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://coryliu.github.io/Blog/blog/tags/hexo/"}]},{"title":"Nginx+uwsgi+CentOS7部署Django","slug":"Nginx-uwsgi-CentOS7部署Django","date":"2019-10-24T15:40:16.000Z","updated":"2020-01-05T06:30:18.547Z","comments":true,"path":"2019/10/24/Nginx-uwsgi-CentOS7部署Django/","link":"","permalink":"https://coryliu.github.io/Blog/2019/10/24/Nginx-uwsgi-CentOS7%E9%83%A8%E7%BD%B2Django/","excerpt":"","text":"","categories":[{"name":"Coding","slug":"Coding","permalink":"https://coryliu.github.io/Blog/blog/categories/Coding/"},{"name":"Django","slug":"Coding/Django","permalink":"https://coryliu.github.io/Blog/blog/categories/Coding/Django/"}],"tags":[{"name":"Django","slug":"Django","permalink":"https://coryliu.github.io/Blog/blog/tags/Django/"}]},{"title":"CAGED系统","slug":"CAGED系统","date":"2019-10-24T15:38:43.000Z","updated":"2020-01-05T06:30:18.547Z","comments":true,"path":"2019/10/24/CAGED系统/","link":"","permalink":"https://coryliu.github.io/Blog/2019/10/24/CAGED%E7%B3%BB%E7%BB%9F/","excerpt":"","text":"","categories":[{"name":"Guitar","slug":"Guitar","permalink":"https://coryliu.github.io/Blog/blog/categories/Guitar/"},{"name":"乐理","slug":"Guitar/乐理","permalink":"https://coryliu.github.io/Blog/blog/categories/Guitar/%E4%B9%90%E7%90%86/"}],"tags":[{"name":"乐理","slug":"乐理","permalink":"https://coryliu.github.io/Blog/blog/tags/%E4%B9%90%E7%90%86/"}]},{"title":"七和弦","slug":"七和弦","date":"2019-10-24T15:35:38.000Z","updated":"2020-01-05T06:30:18.547Z","comments":true,"path":"2019/10/24/七和弦/","link":"","permalink":"https://coryliu.github.io/Blog/2019/10/24/%E4%B8%83%E5%92%8C%E5%BC%A6/","excerpt":"七和弦的分类1. 由4个音按照三度叠加构成，根音与最高音之间成七度音程 2. 七和弦的分类：在C大调顺阶和弦中，所有的三和弦都可以变化成七和弦 常用七和弦的组成音 Maj7：1-3-5-7 (大七和弦) Dom7：1-3-5-b7 (属七和弦) min7：1-b3-5-b7 (小七和弦)","text":"七和弦的分类1. 由4个音按照三度叠加构成，根音与最高音之间成七度音程 2. 七和弦的分类：在C大调顺阶和弦中，所有的三和弦都可以变化成七和弦 常用七和弦的组成音 Maj7：1-3-5-7 (大七和弦) Dom7：1-3-5-b7 (属七和弦) min7：1-b3-5-b7 (小七和弦) 几乎所有七和弦指法(不要背，需学会自己根据音程推导)Seventh（属7） Diminished Seventh（减7） Seventh, Suspended Fourth（7挂4） Major Seventh（大7） Minor Seventh（小7） Minor，Major Seventh（小大7） Major Seventh，Flat Fifth（大7降5） Minor Seeventh，Flat Fifth（小7降5）","categories":[{"name":"Guitar","slug":"Guitar","permalink":"https://coryliu.github.io/Blog/blog/categories/Guitar/"},{"name":"乐理","slug":"Guitar/乐理","permalink":"https://coryliu.github.io/Blog/blog/categories/Guitar/%E4%B9%90%E7%90%86/"}],"tags":[{"name":"乐理","slug":"乐理","permalink":"https://coryliu.github.io/Blog/blog/tags/%E4%B9%90%E7%90%86/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-10-20T15:35:38.000Z","updated":"2020-01-05T06:30:18.547Z","comments":true,"path":"2019/10/20/hello-world/","link":"","permalink":"https://coryliu.github.io/Blog/2019/10/20/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"Coding","slug":"Coding","permalink":"https://coryliu.github.io/Blog/blog/categories/Coding/"},{"name":"Hexo","slug":"Coding/Hexo","permalink":"https://coryliu.github.io/Blog/blog/categories/Coding/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://coryliu.github.io/Blog/blog/tags/Hexo/"}]}]}